T1	background_claim 1862 1974	Physically-based cloth animation has been a problem of interest to the graphics community for more than a decade
T2	background_claim 1976 2007	Early work by Terzopoulos et al
T3	background_claim 2016 2045	and Terzopoulos and Fleischer
T4	background_claim 2059 2156	on deformable models correctly characterized cloth simulation as a problem in deformable surfaces
T5	background_claim 2162 2258	applied techniques from the mechanical engineering and finite element communities to the problem
R1	parts_of_same Arg1:T4 Arg2:T3	
R2	parts_of_same Arg1:T3 Arg2:T2	
T6	data 2011 2013	17
T7	data 2048 2050	15
T8	data 2053 2055	16
R3	supports Arg1:T6 Arg2:T2	
R4	supports Arg1:T7 Arg2:T3	
R5	supports Arg1:T8 Arg2:T3	
R6	supports Arg1:T8 Arg2:T5	
R7	supports Arg1:T7 Arg2:T5	
R8	supports Arg1:T6 Arg2:T5	
T9	background_claim 2272 2293	other research groups
T10	background_claim 2406 2442	have taken up the challenge of cloth
R9	parts_of_same Arg1:T10 Arg2:T9	
T11	data 2322 2323	4
T12	data 2346 2348	20
T13	data 2351 2353	21
T14	data 2373 2374	3
T15	data 2401 2402	5
R10	supports Arg1:T11 Arg2:T9	
R11	supports Arg1:T12 Arg2:T9	
R12	supports Arg1:T13 Arg2:T9	
R13	supports Arg1:T14 Arg2:T9	
R14	supports Arg1:T15 Arg2:T9	
T16	background_claim 2453 2474	specific details vary
T17	data 2532 2574	collision detection and constraint methods
T18	data 2504 2530	numerical solution methods
T19	data 2476 2502	underlying representations
R15	supports Arg1:T19 Arg2:T16	
R16	supports Arg1:T18 Arg2:T16	
R17	supports Arg1:T17 Arg2:T16	
T20	background_claim 2583 2637	there is a deep commonality amongst all the approaches
R18	contradicts Arg1:T20 Arg2:T16	
T21	background_claim 2639 2822	physically-based cloth simulation is formulated as a time-varying partial differential equation which, after discretization, is numerically solved as an ordinary differential equation
T22	data 2848 2870	ẍ = M −1 − ∂E + F . ∂x
R19	supports Arg1:T22 Arg2:T21	
R20	supports Arg1:T21 Arg2:T20	
T23	own_claim 3654 3755	we describe a cloth simulation system that is much faster than previously reported simulation systems
T24	own_claim 3757 3877	Our system’s faster performance begins with the choice of an implicit numerical integration method to solve equation (1)
T25	background_claim 3907 3984	the use of implicit integration methods in cloth simulation is far from novel
T26	background_claim 4038 4073	applied such methods to the problem
T27	background_claim 3986 4020	initial work by Terzopoulos et al.
R21	parts_of_same Arg1:T26 Arg2:T27	
T28	background_claim 4101 4184	research on cloth simulation has generally relied on explicit numerical integration
R22	supports Arg1:T27 Arg2:T25	
T29	data 4023 4025	15
T30	data 4028 4030	16
T31	data 4033 4035	17
R23	supports Arg1:T29 Arg2:T27	
R24	supports Arg1:T30 Arg2:T27	
R25	supports Arg1:T31 Arg2:T27	
T32	data 4194 4208	Euler’s method
T33	data 4212 4231	Runge-Kutta methods
T34	background_claim 4233 4258	to advance the simulation
R26	parts_of_same Arg1:T34 Arg2:T28	
R27	supports Arg1:T32 Arg2:T28	
R28	supports Arg1:T33 Arg2:T28	
T35	background_claim 4303 4320	analogous methods
T36	data 4282 4301	energy minimization
T37	data 4329 4345	steepest-descent
R29	supports Arg1:T36 Arg2:T35	
R30	supports Arg1:T37 Arg2:T35	
T38	data 4349 4350	3
T39	data 4353 4355	10
R31	supports Arg1:T38 Arg2:T35	
R32	supports Arg1:T39 Arg2:T35	
R33	parts_of_same Arg1:T35 Arg2:T34	
T40	own_claim 4359 4378	This is unfortunate
T41	background_claim 4500 4568	This results in a “stiff” underlying differential equation of motion
T42	data 4572 4574	12
R34	supports Arg1:T42 Arg2:T41	
T43	background_claim 4380 4421	Cloth strongly resists stretching motions
T44	background_claim 4428 4498	being comparatively permissive in allowing bending or shearing motions
R35	contradicts Arg1:T44 Arg2:T43	
R36	supports Arg1:T44 Arg2:T41	
T45	background_claim 4578 4636	Explicit methods are ill-suited to solving stiff equations
T46	data 4645 4723	they require many small steps to stably advance the simulation forward in time
R37	supports Arg1:T46 Arg2:T45	
T47	background_claim 4740 4838	the computational cost of an explicit method greatly limits the realizable resolution of the cloth
R38	supports Arg1:T45 Arg2:T47	
T48	background_claim 4840 4894	For some applications, the required spatial resolution
T49	background_claim 4942 4958	can be quite low
R39	parts_of_same Arg1:T49 Arg2:T48	
T50	background_claim 4960 5004	a resolution of only a few hundred particles
T51	background_claim 5066 5130	can be sufficient when it comes to modeling flags or tablecloths
R40	parts_of_same Arg1:T51 Arg2:T50	
R41	supports Arg1:T50 Arg2:T49	
T52	background_claim 5132 5151	To animate clothing
T53	background_claim 5180 5253	requires much higher spatial resolution to adequately represent realistic
T54	background_claim 5279 5315	wrinkling and folding configurations
R42	parts_of_same Arg1:T54 Arg2:T53	
R43	parts_of_same Arg1:T53 Arg2:T52	
T55	own_claim 5352 5450	implicit methods for cloth overcome the performance limits inherent in explicit simulation methods
T56	background_claim 6051 6100	a subject which has been largely ignored thus far
T57	own_claim 5986 6049	We also introduce a simple, unified treatment of damping forces
R44	contradicts Arg1:T56 Arg2:T57	
T58	own_claim 6265 6345	our implementation differs greatly from the implementation by Terzopoulos et al.
T59	data 6349 6351	15
T60	data 6354 6356	17
R45	supports Arg1:T59 Arg2:T58	
R46	supports Arg1:T60 Arg2:T58	
T61	data 6102 6193	A key step in our simulation process is the solution of an O(n) × O(n) sparse linear system
R47	supports Arg1:T61 Arg2:T58	
T62	background_claim 6553 6657	the number of time steps per frame tends to increase along with the problem size, for an explicit method
T63	data 6780 6821	the cost of an explicit step is also O(n)
T64	own_claim 6888 6944	explicit methods for cloth require time O(n 2 )—or worse
R48	supports Arg1:T63 Arg2:T64	
T65	background_claim 6360 6387	which for large simulations
T66	background_claim 7070 7123	used an “alternating-direction” implicit (ADI) method
R49	parts_of_same Arg1:T66 Arg2:T65	
T67	data 7126 7128	12
R50	supports Arg1:T67 Arg2:T66	
T68	background_claim 7262 7271	The price
T69	background_claim 7282 7322	is that some of the forces in the system
T70	background_claim 7410 7448	are treated explicitly, not implicitly
R51	parts_of_same Arg1:T70 Arg2:T69	
R52	parts_of_same Arg1:T69 Arg2:T68	
T71	own_claim 7451 7460	The speed
T72	own_claim 7472 7531	with which our sparse linear systems can be robustly solved
T73	own_claim 7584 7671	has convinced us that there is no benefit to be gained from using an ADI method instead
R53	parts_of_same Arg1:T73 Arg2:T72	
R54	parts_of_same Arg1:T72 Arg2:T71	
R55	contradicts Arg1:T71 Arg2:T70	
T74	background_claim 7132 7182	An ADI method generates a series of tightly banded
T75	background_claim 7209 7259	linear systems rather than one large sparse system
R56	parts_of_same Arg1:T75 Arg2:T74	
T76	background_claim 7193 7207	quickly solved
R57	supports Arg1:T75 Arg2:T76	
T77	own_claim 7780 7835	we treat all forces as part of the implicit formulation
T78	own_claim 7871 7929	numerical stability has not been an issue for our simulato
R58	supports Arg1:T73 Arg2:T77	
T79	own_claim 8489 8631	Our formulation for directly imposing and maintaining constraints is harmonious with the use of an extremely fast iterative solution algorithm
T80	background_claim 8766 8830	Iterative methods do not in general solve linear systems exactly
T81	own_claim 8907 8933	A property of our approach
T82	own_claim 8944 8990	is that the constraints are maintained exactly
R59	parts_of_same Arg1:T82 Arg2:T81	
R60	contradicts Arg1:T81 Arg2:T80	
T83	own_claim 8177 8335	our simulator enforces constraints without introducing additional penalty terms in the energy function E or adding Lagrange-multiplier forces into the force F
T84	own_claim 8338 8389	This sort of direct constraint treatment is trivial
T85	data 8393 8445	equation (1) is integrated using explicit techniques
R61	supports Arg1:T85 Arg2:T84	
T86	own_claim 8451 8465	is problematic
T87	data 8470 8486	implicit methods
R62	supports Arg1:T87 Arg2:T86	
R63	contradicts Arg1:T86 Arg2:T84	
T88	own_claim 9214 9305	The combination of implicit integration and direct constraint satisfaction is very powerful
T89	own_claim 9315 9380	this approach almost always allows us to take large steps forward
R64	supports Arg1:T89 Arg2:T88	
T90	own_claim 9394 9494	most of our simulations require on average from two to three time steps per frame of 30 Hz animation
T91	data 9658 9798	in simulating a 6, 000 node system, the solver takes only 50–100 iterations to solve the 18, 000 × 18, 000 linear system formed at each step
T92	own_claim 9537 9643	The large step sizes complement the fact that the CG solver requires relatively few iterations to converge
R65	supports Arg1:T91 Arg2:T92	
T93	own_claim 9814 9908	the running time of our simulator is remarkably insensitive to the cloth’s material properties
T94	own_claim 9960 10031	All of the above advantages translate directly into a fast running time
R66	supports Arg1:T93 Arg2:T94	
R67	supports Arg1:T88 Arg2:T94	
R68	supports Arg1:T90 Arg2:T94	
T95	data 10047 10101	we demonstrate results similar to those in Breen et al
T96	data 10170 10261	with a running time just over 2 seconds per frame on an SGI Octane R10000 195 Mhz processor
T97	data 10110 10129	and Eberhardt et al
R69	parts_of_same Arg1:T96 Arg2:T97	
R70	parts_of_same Arg1:T97 Arg2:T95	
R71	supports Arg1:T95 Arg2:T94	
T98	own_claim 10315 10414	exhibiting complex wrinkling and folding behavior on both key-framed and motion-captured characters
T99	own_claim 10274 10290	we show garments
T100	data 10292 10298	shirts
T101	data 10300 10305	pants
T102	data 10307 10313	skirts
R72	supports Arg1:T100 Arg2:T99	
R73	supports Arg1:T101 Arg2:T99	
R74	supports Arg1:T102 Arg2:T99	
R75	parts_of_same Arg1:T98 Arg2:T99	
T103	data 10501 10557	on a dancing character at a cost of 10 seconds per frame
T104	data 10453 10482	a long skirt with 4,530 nodes
T105	data 10607 10660	with a cost varying between 8 to 14 seconds per frame
T106	data 10563 10587	a shirt with 6,450 nodes
R76	parts_of_same Arg1:T105 Arg2:T106	
R77	parts_of_same Arg1:T103 Arg2:T104	
R78	supports Arg1:T104 Arg2:T98	
R79	supports Arg1:T106 Arg2:T98	
T107	background_claim 10901 10949	This work recognized the need for damping forces
T108	background_claim 10960 11006	only a simple viscous drag force −k x was used
T109	background_claim 10799 10838	discretized cloth as a rectangular mesh
T110	background_claim 10767 10785	Terzopoulos et al.
T111	data 10788 10790	15
T112	data 10793 10795	17
R80	supports Arg1:T112 Arg2:T110	
R81	supports Arg1:T111 Arg2:T110	
R82	parts_of_same Arg1:T109 Arg2:T110	
R83	contradicts Arg1:T108 Arg2:T107	
R84	supports Arg1:T111 Arg2:T107	
R85	supports Arg1:T112 Arg2:T107	
R86	supports Arg1:T111 Arg2:T108	
R87	supports Arg1:T112 Arg2:T108	
T113	background_claim 11575 11598	work by Carignan et al.
T114	background_claim 11607 11722	described a cloth simulation system using rectangular discretization and the same formulation as Terzopoulos et al.
T115	data 11602 11603	4
R88	parts_of_same Arg1:T114 Arg2:T113	
R89	supports Arg1:T115 Arg2:T113	
T116	background_claim 11754 11864	Carignan et al. recognized the need for damping functions which do not penalize rigidbody motions of the cloth
T117	background_claim 11902 11956	they added a force which damps cloth stretch and shear
R90	supports Arg1:T115 Arg2:T116	
R91	supports Arg1:T115 Arg2:T117	
T118	background_claim 12115 12151	no mention is made of damping forces
T119	background_claim 12034 12113	which focuses mainly on collision detection/response and uses a triangular mesh
T120	background_claim 11973 12024	Later work by the same group includes Volino et al.
T121	data 12027 12029	20
R92	parts_of_same Arg1:T119 Arg2:T120	
R93	supports Arg1:T121 Arg2:T120	
R94	supports Arg1:T121 Arg2:T118	
T122	background_claim 12326 12413	gives the only published results we know of for simulated garments on moving characters
T123	background_claim 12247 12281	the accumulated work by this group
R95	parts_of_same Arg1:T122 Arg2:T123	
R96	supports Arg1:T120 Arg2:T123	
R97	supports Arg1:T109 Arg2:T123	
T124	background_claim 12663 12731	depart completely from continuum formulations of the energy function
T125	background_claim 12643 12655	Breen et al.
T126	data 12658 12659	3
R98	parts_of_same Arg1:T124 Arg2:T125	
R99	supports Arg1:T126 Arg2:T125	
T127	background_claim 12737 12802	describe what they call a “particlebased” approach to the problem
R100	supports Arg1:T126 Arg2:T127	
T128	background_claim 12804 12857	By making use of real-world cloth material properties
T129	background_claim 12890 13018	they produced highly realistic static images of draped rectangular cloth meshes with reported resolutions of up to 51 × 51 nodes
R101	parts_of_same Arg1:T129 Arg2:T128	
R102	supports Arg1:T126 Arg2:T128	
T130	background_claim 13020 13071	The focus of this work is on static poses for cloth
T131	background_claim 13104 13226	their simulation process is best described as energy minimization, although methods analogous to explicit methods are used
R103	supports Arg1:T130 Arg2:T131	
T132	background_claim 13228 13271	Speed was of secondary concern in this work
R104	supports Arg1:T126 Arg2:T130	
R105	supports Arg1:T126 Arg2:T132	
T133	background_claim 13458 13492	obtain similarly realistic results
T134	background_claim 13500 13598	dropping the computational cost to approximately 20–30 minutes per frame on an SGI R8000 processor
T135	background_claim 13273 13304	Refinements by Eberhardt et al.
T136	data 13307 13308	5
R106	supports Arg1:T136 Arg2:T135	
R107	parts_of_same Arg1:T133 Arg2:T135	
R108	supports Arg1:T136 Arg2:T134	
T137	background_claim 13652 13755	focuses on improving the performance of explicit methods by a post-step modification of nodal positions
T138	background_claim 13637 13643	Provot
T139	data 13646 13648	13
R109	parts_of_same Arg1:T137 Arg2:T138	
R110	supports Arg1:T139 Arg2:T138	
T140	background_claim 13827 13880	the convergence properties of this method are unclear
T141	background_claim 13757 13825	He iteratively adjusts nodal positions to eliminate unwanted stretch
T142	background_claim 13882 13984	A more comprehensive discussion on cloth research can be found in the survey paper by Ng and Grimsdale
T143	data 13988 13989	9
R111	supports Arg1:T143 Arg2:T142	
R112	supports Arg1:T139 Arg2:T141	
R113	supports Arg1:T139 Arg2:T140	
T144	own_claim 15823 15864	this simple test may miss some collisions
T145	data 15783 15821	relative velocities are extremely high
R114	supports Arg1:T145 Arg2:T144	
T146	own_claim 15880 16001	analytically checking for intersection between previous and current positions can guarantee that no collisions are missed
T147	own_claim 16471 16596	The most critical forces in the system are the internal cloth forces which impart much of the cloth’s characteristic behavior
T148	background_claim 16618 16767	describes the use of the Kawabata system of measurement for realistic determination of the in-plane shearing and out-of-plane bending forces in cloth
T149	background_claim 16598 16610	Breen et al.
T150	data 16613 16614	3
R115	parts_of_same Arg1:T148 Arg2:T149	
R116	supports Arg1:T150 Arg2:T149	
T151	background_claim 17135 17190	cloth does not stretch appreciably under its own weight
T152	data 17116 17133	normal conditions
R117	supports Arg1:T152 Arg2:T151	
T153	own_claim 17192 17263	This requires the stretch force to have a high coefficient of stiffness
R118	supports Arg1:T151 Arg2:T153	
T154	own_claim 17278 17360	it is the stretch force that is most responsible for the stiffness of equation (1)
T155	background_claim 17362 17493	A common practice in explicitly integrated cloth systems is to improve running time by decreasing the strength of the stretch force
T156	own_claim 17504 17545	this leads to “rubbery” or “bouncy” cloth
R119	contradicts Arg1:T156 Arg2:T155	
T157	own_claim 17547 17673	Our system uses a very stiff stretch force to combat this problem, without any detrimental effects on the run-time performance
T158	own_claim 17681 17767	the shear and bend force stiffness coefficients depend on the material being simulated
T159	own_claim 17769 17850	the stretch coefficient is essentially the same (large) value for all simulations
R120	contradicts Arg1:T159 Arg2:T158	
T160	own_claim 17956 18026	Complementing the above three internal forces are three damping forces
T161	own_claim 18042 18116	we formulate damping forces that subdue any oscillations having to do with
T162	data 18031 18040	section 5
R121	supports Arg1:T162 Arg2:T161	
T163	own_claim 18188 18259	The damping forces do not dissipate energy due to other modes of motion
T164	own_claim 18261 18347	Additional forces include air-drag, gravity, and user-generated generated mouse-forces
T165	own_claim 18379 18470	Cloth/cloth contacts generate strong repulsive linear-spring forces between cloth particles
T166	own_claim 18520 18624	the acceleration ẍ i of the ith particle is simply ẍ i = f i /m i , where m i is the ith particle’s mass
T167	data 18472 18518	Combining all forces into a net force vector f
R122	supports Arg1:T167 Arg2:T166	
R123	supports Arg1:T164 Arg2:T166	
R124	supports Arg1:T165 Arg2:T166	
R125	supports Arg1:T163 Arg2:T166	
T168	own_claim 18760 18921	to accommodate pieces of cloth that have been topologically seamed together (such as a sleeve), particles lying on the seam must have multiple (u, v) coordinates
T169	own_claim 18705 18749	each particle has a unique (u, v) coordinate
R126	contradicts Arg1:T168 Arg2:T169	
T170	own_claim 19026 19073	The (u, v) coordinates are useful for texturing
T171	data 19246 19368	Defining the diagonal mass matrix M ∈ IR 3n×3n by diag(M) = (m 1 , m 1 , m 1 , m 2 , m 2 , m 2 , . . . , m n , m n , m n )
T172	own_claim 19426 19442	ẍ = M −1 f(x, x)
R127	supports Arg1:T171 Arg2:T172	
T173	own_claim 19586 19632	generates large unbanded sparse linear systems
T174	own_claim 19512 19553	The use of an implicit integration method
T175	data 19572 19584	next section
R128	parts_of_same Arg1:T173 Arg2:T174	
R129	supports Arg1:T175 Arg2:T174	
T176	own_claim 19634 19716	We solve these systems through a modified conjugate gradient (CG) iterative method
T177	data 19731 19740	section 5
R130	supports Arg1:T177 Arg2:T176	
T178	background_claim 19742 19782	CG methods exploit sparsity quite easily
T179	data 19790 19839	they are based solely on matrix-vector multiplies
R131	supports Arg1:T179 Arg2:T178	
T180	background_claim 19845 19895	require only rudimentary sparse storage techniques
T181	own_claim 19897 19997	The sparsity of the matrix generated by the implicit integrator is best represented in block-fashion
T182	data 19999 20133	for a system with n particles, we deal with an n × n matrix, whose non-zero entries are represented as dense 3 × 3 matrices of scalars
R132	supports Arg1:T182 Arg2:T181	
T183	own_claim 20467 20535	The overall implementation of sparsity is completely straightforward
T184	own_claim 20592 20707	An individual particle’s position and velocity can be completely controlled in either one, two, or three dimensions
T185	own_claim 20709 20775	Particles can thus be attached to a fixed or moving point in space
T186	own_claim 20780 20829	constrained to a fixed or moving surface or curve
R133	supports Arg1:T184 Arg2:T185	
R134	supports Arg1:T184 Arg2:T186	
T187	own_claim 21367 21470	The constraint techniques we use on individual particles work just as well for collections of particles
T188	own_claim 21478 21549	we could handle cloth/cloth intersections using the technique described
T189	data 21553 21562	section 5
R135	supports Arg1:T189 Arg2:T188	
R136	supports Arg1:T187 Arg2:T188	
T190	own_claim 21568 21597	the cost is potentially large
R137	contradicts Arg1:T190 Arg2:T188	
T191	own_claim 21616 21685	we have chosen to deal with cloth/cloth contacts using penalty forces
R138	supports Arg1:T190 Arg2:T191	
T192	own_claim 21886 21941	The implicit solver easily tolerates these stiff forces
R139	supports Arg1:T191 Arg2:T192	
T193	own_claim 22087 22177	our goal is to determine a new position x(t 0 + h) and velocity x(t 0 + h) at time t 0 + h
T194	data 22011 22084	the known position x(t 0 ) and velocity x(t 0 ) of the system at time t 0
R140	supports Arg1:T194 Arg2:T193	
T195	own_claim 22246 22323	we must first transform equation (2) into a first-order differential equation
T196	own_claim 22325 22414;22415 22423;22424 22435;22436 22482	This is accomplished simply by defining the system’s velocity v as v = x and then writing                    3           dt d x x = dt d v x = M −1 f(x, v v)
T197	own_claim 22965 23043	the step size h must be quite small to ensure stability when using this method
T198	data 22943 22963	previously discussed
R141	supports Arg1:T198 Arg2:T197	
T199	own_claim 23225 23436	The difference in the two methods is that the forward method’s step is based solely on conditions at time t 0 while the backward method’s step is written in terms of conditions at the terminus of the step itself
T200	own_claim 23045 23104	The implicit backward Euler method appears similar at first
T201	data 22774 22876;22877 22938	The explicit forward Euler method applied to equation (3) approximates x and v as x v = h M v −1 0 f 0         where the force f 0 is defined by f 0 = f(x 0 , v 0 )
R142	supports Arg1:T201 Arg2:T200	
T202	data 23106 23133;23134 23142;23143 23154;23155 23205	x and v are approximated by                    4           v x = h M −1 f(x 0 v + 0 + x, v v 0 + v)
R143	supports Arg1:T202 Arg2:T200	
T203	data 23440 23504	The forward method requires only an evaluation of the function f
T204	data 23509 23599	the backward method requires that we solve for values of x and v that satisfy equation (4)
R144	supports Arg1:T204 Arg2:T199	
R145	supports Arg1:T203 Arg2:T199	
T205	own_claim 23639 23834	rather than solve this equation exactly (which would require iteration) we apply a Taylor series expansion to f and make the firstorder approximation ∂f ∂f f(x 0 + x, v 0 + v) = f 0 + ∂x x + ∂v v
T206	data 23601 23637	Equation (4) is a nonlinear equation
R146	supports Arg1:T206 Arg2:T205	
T207	own_claim 24486 24643	the backward Euler step consists of evaluating f 0 , ∂f/∂x and ∂f/∂v; forming the system in equation (6); solving the system for v; and then updating x and v
T208	data 23854 23938	the derivative ∂f/∂x is evaluated for the state (x 0 , v 0 ) and similarly for ∂f/∂v
T209	data 24046 24092	v x = h M −1 (f 0 + v 0 ∂x ∂f + x v + ∂v ∂f v)
T210	data 23940 24014	Substituting this approximation into equation (4) yields the linear system
T211	data 24112 24231	Taking the bottom row of equation (5) and substituting x = h(v 0 + v) yields v = hM −1 f 0 + ∂x ∂f h(v 0 + v) + ∂v ∂f v
T212	data 24329 24389	I − hM −1 ∂v ∂f − h 2 M −1 ∂x ∂f v = hM −1 f 0 + h ∂x ∂f v 0
T213	data 24234 24297	Letting I denote the identity matrix, and regrouping, we obtain
R147	parts_of_same Arg1:T212 Arg2:T213	
T214	data 24407 24432	which we then solve for v
R148	parts_of_same Arg1:T214 Arg2:T212	
T215	data 24434 24478	Given v, we trivially compute x = h(v 0 + v)
R149	supports Arg1:T215 Arg2:T207	
R150	supports Arg1:T212 Arg2:T207	
R151	supports Arg1:T211 Arg2:T207	
R152	parts_of_same Arg1:T209 Arg2:T210	
R153	supports Arg1:T208 Arg2:T207	
R154	supports Arg1:T209 Arg2:T207	
T216	own_claim 24866 24903	The method is called “backward” Euler
T217	data 24912 25027	starting from the output state (x 0 + x, v 0 + v) and using a forward Euler step to run the system backward in time
R155	supports Arg1:T217 Arg2:T216	
T218	own_claim 25152 25212	Forward Euler takes no notice of wildly changing derivatives
T219	own_claim 25218 25248	proceeds forward quite blindly
T220	own_claim 25275 25370	forces one to find an output state whose derivative at least points back to where you came from
T221	own_claim 25250 25264	Backward Euler
R156	parts_of_same Arg1:T220 Arg2:T221	
R157	contradicts Arg1:T221 Arg2:T218	
R158	contradicts Arg1:T221 Arg2:T219	
T222	own_claim 25846 25888	and then taking derivatives is impractical
T223	own_claim 25732 25787	Expressing the energy E as a single monolithic function
R159	parts_of_same Arg1:T222 Arg2:T223	
T224	own_claim 25924 25994	A better approach is decompose E into a sum of sparse energy functions
R160	supports Arg1:T223 Arg2:T224	
T225	own_claim 26117 26178	even decomposing E into sparse energy functions is not enough
R161	contradicts Arg1:T225 Arg2:T224	
T226	own_claim 26180 26230	Energy functions are an undesirable starting point
T227	data 26239 26305	sensible damping functions cannot be derived from energy functions
R162	supports Arg1:T227 Arg2:T226	
R163	supports Arg1:T226 Arg2:T225	
T228	own_claim 26316 26497	we define internal behavior by formulating a vector condition C(x) which we want to be zero, and then defining the associated energy as k C(x) T C(x) where k is a stiffness constant
R164	supports Arg1:T225 Arg2:T228	
T229	own_claim 26602 26845	An added bonus is that starting from this vector-based energy description tends to result in a simpler, more compact, and more easily coded formulation for ∂f/∂x than proceeding from an energy function in which the structure of C has been lost
T230	own_claim 28069 28172	We can now easily describe the internal forces acting on the cloth, by just writing condition functions
T231	own_claim 28174 28221	Forces and their derivatives are easily derived
R165	supports Arg1:T231 Arg2:T230	
T232	data 28228 28241	equations (7)
T233	data 28246 28249	(8)
T234	own_claim 28515 28657	it will be convenient to pretend momentarily that we have a single continuous function w(u, v) that maps from plane coordinates to world space
T235	background_claim 28962 29073	Some previous continuum formulations have modeled stretch energy along an axis as essentially (w u T w u − 1) 2
T236	data 29119 29121	15
T237	data 29124 29126	16
T238	data 29129 29131	17
T239	data 29134 29135	4
R166	supports Arg1:T236 Arg2:T235	
R167	supports Arg1:T237 Arg2:T235	
R168	supports Arg1:T238 Arg2:T235	
R169	supports Arg1:T239 Arg2:T235	
T240	own_claim 29139 29174	We find this to be needlessly stiff
T241	own_claim 29183 29222	near the rest state, the force gradient
T242	own_claim 29256 29380	is quite small, which partially negates the advantage implicit integration has in exploiting knowledge of the force gradient
R170	parts_of_same Arg1:T242 Arg2:T241	
R171	supports Arg1:T241 Arg2:T240	
T243	own_claim 29382 29443	A quadratic model for energy is, numerically, a better choice
R172	supports Arg1:T242 Arg2:T243	
T244	own_claim 30978 31082	We have found the ability to control shrink/stretch anisotropically to be an indispensable modeling tool
T245	own_claim 30887 30956	we might decrease b v near the end of a sleeve, inducing a tight cuff
T246	data 30961 30976	on a sweatshirt
R173	supports Arg1:T246 Arg2:T245	
T247	own_claim 31195 31304	We can measure the extent to which cloth has sheared in a triangle by considering the inner product w u T w v
T248	own_claim 31326 31346	this product is zero
T249	data 31314 31324	rest state
R174	supports Arg1:T249 Arg2:T248	
T250	own_claim 31437 31458	we need not normalize
T251	data 31354 31435	the stretch term prevents the magnitudes of w u and w v from changing overly much
R175	supports Arg1:T251 Arg2:T250	
T252	own_claim 31494 31564	the product w u T w v is a reasonable approximation to the shear angle
T253	data 31463 31492	the small angle approximation
R176	supports Arg1:T253 Arg2:T252	
T254	own_claim 32577 32637	the condition C should not be scaled by the triangles’ areas
T255	own_claim 32514 32575	increases at the same rate that the triangle’s area decreases
T256	own_claim 32440 32467	the square of the curvature
R177	parts_of_same Arg1:T255 Arg2:T256	
R178	supports Arg1:T255 Arg2:T254	
T257	own_claim 32861 32927	Rectangular meshes make it simple to treat bending anisotropically
T258	own_claim 32929 33022	The uv coordinates associated with particles make this possible for triangular meshes as well
T259	own_claim 33278 33356	The stiffness weighting for this edge should simply be k u ( u) 2 + k v ( v) 2
T260	data 33244 33275	u = u i − u j and v = v i − v j
T261	data 33172 33231	the edge between the triangles be between particles i and j
T262	data 33030 33122	material for which bending in the u and v directions are weighted by stiffnesses k u and k v
R179	supports Arg1:T261 Arg2:T259	
R180	supports Arg1:T260 Arg2:T259	
R181	supports Arg1:T262 Arg2:T259	
R182	supports Arg1:T259 Arg2:T258	
T263	own_claim 33724 33775	These forces and their gradients are easily derived
T264	own_claim 33828 33894	The energies we have just described are functions of position only
T265	background_claim 33938 34041	is critically dependent on well-chosen damping forces that are a function of both position and velocity
T266	background_claim 33896 33927	Robust dynamic cloth simulation
R183	parts_of_same Arg1:T265 Arg2:T266	
T267	own_claim 34056 34135	the strong stretch force must be accompanied by a suitably strong damping force
T268	data 34139 34229	we are to prevent anomalous in-plane oscillations from arising between connected particles
R184	supports Arg1:T268 Arg2:T267	
R185	supports Arg1:T267 Arg2:T265	
T269	own_claim 34240 34343	this strong damping force must confine itself solely to damping in-plane stretching/compressing motions
T270	own_claim 34345 34436	stretch damping should not arise due to motions that are not causing stretch or compression
R186	supports Arg1:T270 Arg2:T269	
T271	background_claim 34472 34596	treatment of cloth used a simple viscous damping function which dissipated kinetic energy, independent of the type of motion
T272	background_claim 34438 34458	Terzopoulos et al.’s
T273	data 34461 34463	16
T274	data 34466 34468	17
R187	parts_of_same Arg1:T271 Arg2:T272	
R188	supports Arg1:T273 Arg2:T272	
R189	supports Arg1:T274 Arg2:T272	
T275	background_claim 34621 34695	improved upon this somewhat, borrowing a formulation due to Platt and Barr
T276	background_claim 34598 34613	Carignan et al.
T277	data 34616 34617	4
R190	parts_of_same Arg1:T275 Arg2:T276	
R191	supports Arg1:T277 Arg2:T276	
T278	data 34698 34700	11
R192	supports Arg1:T278 Arg2:T275	
T279	background_claim 34766 34840	does not match the quartic energy functions of their continuum formulation
T280	background_claim 34713 34735	their damping function
R193	parts_of_same Arg1:T279 Arg2:T280	
R194	supports Arg1:T277 Arg2:T280	
T281	own_claim 34858 34966	we describe a general treatment for damping that is independent of the specific energy function being damped
T282	data 34845 34857	this section
R195	supports Arg1:T282 Arg2:T281	
R196	contradicts Arg1:T281 Arg2:T279	
T283	own_claim 35102 35135	This is an easy trap to fall into
T284	own_claim 34968 35082	It is tempting to formulate a damping function for an energy function E(x) by measuring the velocity of the energy
T285	own_claim 35141 35169	it gives nonsensical results
T286	own_claim 35269 35349	E  ̇ is zero when E is at its minimum, regardless of the system’s velocity x = v
T287	data 35236 35254	E  ̇ = (∂E/∂x) T x
R197	supports Arg1:T287 Arg2:T286	
T288	own_claim 35171 35228	At an equilibrium point of E, the gradient ∂E/∂x vanishes
T289	own_claim 35363 35416	E  ̇ is always too small near the system’s rest state
T290	own_claim 35427 35485	basing the damping force on E  ̇ is not what we want to do
R198	supports Arg1:T289 Arg2:T290	
R199	supports Arg1:T286 Arg2:T289	
R200	supports Arg1:T286 Arg2:T288	
R201	supports Arg1:T288 Arg2:T285	
T291	own_claim 35503 35644	the damping function should be defined not in terms of the energy E, but in terms of the condition C(x) we have been using to define energies
R202	supports Arg1:T290 Arg2:T291	
T292	own_claim 35646 35750	The force f arising from the energy acts only in the direction ∂C(x)/∂x, and so should the damping force
T293	own_claim 35766 35865	the damping force should depend on the component of the system’s velocity in the ∂C(x)/∂x direction
T294	own_claim 36082 36104	d = −k d ∂C(x) ∂x C(x)
T295	own_claim 35986 36049	the damping force d associated with a condition C have the form
R203	parts_of_same Arg1:T294 Arg2:T295	
T296	own_claim 35883 35942	the damping strength should depend on (∂C(x)/∂x) T x = C(x)
R204	supports Arg1:T293 Arg2:T296	
R205	supports Arg1:T296 Arg2:T295	
R206	supports Arg1:T292 Arg2:T295	
T297	own_claim 36132 36184	This neatly parallels the fact that f = −k s ∂x C(x)
T298	own_claim 36418 36486	we can now add accompanying damping forces by applying equation (11)
T299	data 36324 36416	the condition functions C we have defined in this section for stretch, bend and shear forces
R207	supports Arg1:T299 Arg2:T298	
T300	own_claim 37028 37106	we find it expedient simply to leave this term out, thereby restoring symmetry
T301	data 37015 37026	section 5.2
R208	supports Arg1:T301 Arg2:T300	
T302	own_claim 36681 36749	∂x ∂d i j = −k d ∂C(x) ∂x i ∂ C(x) ∂x  ̇ j T + ∂ ∂x C(x) i ∂x j C(x)
T303	own_claim 36639 36648	we obtain
T304	data 36608 36637	Differentiating equation (11)
R209	supports Arg1:T304 Arg2:T303	
R210	parts_of_same Arg1:T302 Arg2:T303	
T305	own_claim 36867 36906	we cannot expect ∂d/∂x to be symmetrica
T306	data 36782 36831	∂d/∂x is not a second derivative of some function
R211	supports Arg1:T306 Arg2:T305	
R212	supports Arg1:T302 Arg2:T305	
T307	own_claim 37108 37165	This simplification is clearly not physically justifiable
T308	own_claim 37171 37226	we have not observed any ill effects from this omission
R213	supports Arg1:T308 Arg2:T300	
R214	contradicts Arg1:T308 Arg2:T307	
T309	own_claim 37556 37608	the result is symmetrical without dropping any terms
T310	data 37354 37378	C(x)  ̇ = (∂C(x)/∂x) T v
T311	own_claim 37388 37419	∂ C(x)  ̇ ∂ ∂C(x) T ∂C(x) = v =
T312	own_claim 37422 37433	∂v ∂v ∂x ∂x
R215	parts_of_same Arg1:T312 Arg2:T311	
R216	supports Arg1:T310 Arg2:T311	
T313	own_claim 37464 37539	∂v ∂d i j = −k d ∂C(x) ∂x i ∂ C(x) ∂v  ̇ j T = −k d ∂C(x) ∂x i ∂C(x) ∂x j T
R217	supports Arg1:T312 Arg2:T313	
R218	supports Arg1:T313 Arg2:T309	
T314	own_claim 37991 38078	The techniques we describe in this section could be used for multi-particle constraints
T315	own_claim 38089 38144	constraints that share particle would need to be merged
R219	contradicts Arg1:T315 Arg2:T314	
T316	own_claim 38152 38186	a set of four-particle constraints
T317	own_claim 38248 38355	might merge to form a single constraint on arbitrarily many particles, which would be expensive to maintain
R220	parts_of_same Arg1:T317 Arg2:T316	
T318	data 38196 38246	vertex/triangle or edge/edge contacts in the cloth
R221	supports Arg1:T318 Arg2:T316	
R222	supports Arg1:T315 Arg2:T316	
T319	own_claim 38374 38424	we handle cloth/cloth contacts with strong springs
T320	own_claim 38505 38531	and “position alteration,”
T321	data 38557 38566	section 6
R223	supports Arg1:T321 Arg2:T320	
R224	parts_of_same Arg1:T320 Arg2:T319	
R225	supports Arg1:T317 Arg2:T319	
T322	own_claim 38810 38920	it is the particle’s acceleration, or equivalently, the change in the particle’s velocity, that is constrained
T323	data 38766 38808	the differential nature of our formulation
R226	supports Arg1:T323 Arg2:T322	
T324	own_claim 38983 39032	we are explicitly setting the particle’s velocity
T325	own_claim 39100 39192	we are constraining the particle’s velocity along either two or one mutually orthogonal axes
T326	data 38925 38976	the particle is constrained in all three dimensions
R227	supports Arg1:T326 Arg2:T324	
T327	data 39056 39098	the constraint is in two or one dimensions
R228	supports Arg1:T327 Arg2:T325	
R229	supports Arg1:T324 Arg2:T322	
R230	supports Arg1:T325 Arg2:T322	
T328	own_claim 39384 39532	An obvious and quite exact method for constraining a particle is to reduce the number of coordinates describing the particle’s position and velocity
T329	own_claim 39534 39593	A completely constrained particle would have no coordinates
T330	own_claim 39601 39671	a particle with one dimension of constraint would have two coordinates
R232	supports Arg1:T328 Arg2:T329	
R233	supports Arg1:T328 Arg2:T330	
T331	own_claim 39673 39689	This is possible
T332	own_claim 39694 39729	it complicates the system immensely
R231	contradicts Arg1:T332 Arg2:T331	
T333	data 39734 39782	we change the number of coordinates per particle
T334	own_claim 39784 39877	we alter the size of the derivative matrices in equation (6), as well as the sparsity pattern
R234	supports Arg1:T333 Arg2:T334	
T335	own_claim 40056 40080	this is most unappealing
T336	data 39986 40054	the transient nature of contact constraints between cloth and solids
R235	supports Arg1:T336 Arg2:T335	
T337	own_claim 40082 40161	The computation of the derivative matrices’ entries is also greatly complicated
T338	own_claim 40171 40290	we must now introduce extra Jacobian matrices that relate a particle’s reduced coordinates to its motion in world-space
R236	supports Arg1:T338 Arg2:T337	
T339	own_claim 40301 40431	correct constraint-release behavior between cloth and solid objects is difficult to achieve using a reduced coordinate formulation
T340	own_claim 40458 40508	we immediately rejected this method of constraints
R237	supports Arg1:T339 Arg2:T340	
R238	supports Arg1:T337 Arg2:T340	
R239	supports Arg1:T335 Arg2:T340	
R240	supports Arg1:T334 Arg2:T340	
T341	own_claim 40556 40627	We could constrain particles through the use of strong energy functions
T342	own_claim 40845 40872	do not carry as much weight
T343	own_claim 40765 40823	the usual objections to enforcing constraints with springs
T344	own_claim 40904 40970	found it to be a not unreasonable constraint enforcement mechanism
T345	data 40711 40763	our entire formulation is geared to handle stiffness
R241	parts_of_same Arg1:T342 Arg2:T343	
R242	supports Arg1:T345 Arg2:T343	
T346	data 40874 40898	We tried this for a time
R243	supports Arg1:T346 Arg2:T344	
T347	background_claim 40981 41031	penalty methods do not enforce constraints exactly
T348	background_claim 41037 41088	they do add some additional stiffness to the system
T349	own_claim 41181 41263	we turned away from penalty methods except in the case of cloth/cloth interactions
T350	data 41096 41150	the mechanism we describe enforces constraints exactly
T351	data 41156 41179	adds no extra stiffness
R244	supports Arg1:T351 Arg2:T349	
R245	supports Arg1:T350 Arg2:T349	
R246	supports Arg1:T347 Arg2:T349	
R247	supports Arg1:T348 Arg2:T349	
R248	supports Arg1:T344 Arg2:T349	
T352	own_claim 41316 41363	We could introduce additional constraint forces
T353	own_claim 41394 41436	into our system to satisfy the constraints
R249	parts_of_same Arg1:T352 Arg2:T353	
T354	own_claim 41536 41555	and extra equations
T355	own_claim 41438 41517	This involves augmenting the linear system of equation (6) with extra variables
R250	parts_of_same Arg1:T354 Arg2:T355	
T356	own_claim 41600 41663	this turns a positive definite system into an indefinite system
T357	own_claim 41682 41747	iterative methods such as CG will need to square the system first
T358	own_claim 41757 41782	doubling the running time
T359	own_claim 41787 41846	degrading the numerical conditionining of the linear system
R251	supports Arg1:T356 Arg2:T357	
R252	supports Arg1:T354 Arg2:T356	
R253	supports Arg1:T357 Arg2:T358	
R254	supports Arg1:T357 Arg2:T359	
T360	background_claim 41862 41969	an iterative method will generally not enforce the constraints exactly without a large number of iterations
T361	own_claim 42065 42128	the constraint method we describe steps past these difficulties
T362	own_claim 42133 42179	we turned away from using Lagrange multipliers
T363	own_claim 41972 42026	A direct method for solving the augmented system would
T364	own_claim 42037 42055	avoid this problem
R255	parts_of_same Arg1:T364 Arg2:T363	
R256	supports Arg1:T360 Arg2:T362	
R257	supports Arg1:T361 Arg2:T362	
R258	supports Arg1:T359 Arg2:T362	
R259	supports Arg1:T358 Arg2:T362	
T365	own_claim 42242 42320	The idea behind our constraint enforcement mechanism is described quite simply
T366	own_claim 42331 42410	the actual implementation is somewhat more complicated, to maximize performance
R260	contradicts Arg1:T366 Arg2:T365	
T367	own_claim 42412 42490	A dynamic simulation usually requires knowledge of the inverse mass of objects
T368	data 42510 42560	the appearance of M −1 , and not M in equation (6)
R261	supports Arg1:T368 Arg2:T367	
T369	own_claim 42690 42752	it becomes trivial to enforce constraints by altering the mass
T370	data 42668 42688	inverse mass is used
R262	supports Arg1:T370 Arg2:T369	
T371	own_claim 42861 42898	we give the particle an infinite mass
T372	own_claim 42900 42941	making it ignore all forces exerted on it
T373	data 42835 42859	we take 1/m i to be zero
R263	supports Arg1:T373 Arg2:T371	
R264	supports Arg1:T371 Arg2:T372	
T374	own_claim 42943 43071	Complete control over a particle’s acceleration is thus taken care of by storing a value of zero for the particle’s inverse mass
R265	supports Arg1:T372 Arg2:T374	
T375	own_claim 43222 43246	we need not always do so
T376	own_claim 43170 43220	we normally think of a particle’s mass as a scalar
R266	contradicts Arg1:T375 Arg2:T376	
T377	own_claim 43629 43728	a particle is prevented from accelerating along p by using an inverse mass matrix 1 (I − m i pp T )
T378	data 43762 43778	(I − pp T )p = 0
T379	data 43604 43626	a unit vector p ∈ IR 3
R267	supports Arg1:T378 Arg2:T377	
R268	supports Arg1:T379 Arg2:T377	
T380	own_claim 43843 43967	we prevent a particle from accelerating in either the p or q direction by using the inverse mass matrix 1 (I − pp T − qq T )
T381	data 43797 43841	two mutually orthogonal unit vectors p and q
R269	supports Arg1:T381 Arg2:T380	
T382	own_claim 43973 44097	By allowing constrained particles to have these sorts of inverse masses, we can build constraints directly into equation (6)
R270	supports Arg1:T380 Arg2:T382	
R271	supports Arg1:T377 Arg2:T382	
T383	own_claim 44829 44922	We are not limited to constraining particles to have zero accelerations in certain directions
T384	own_claim 44932 45014	we control exactly what the change in velocity is along the constrained directions
T385	own_claim 45149 45217	we can choose any value of z i for a completely constrained particle
T386	data 45225 45255	all directions are constrained
T387	data 45307 45339	it has no constrained directions
T388	own_claim 45260 45300	unconstrained particle must have z i = 0
T389	own_claim 45357 45412	we rewrite equation (6) to directly enforce constraints
T390	data 45020 45133	every particle i, let z i be the change in velocity we wish to enforce in the particle’s constrained direction(s)
R272	supports Arg1:T390 Arg2:T385	
R273	supports Arg1:T386 Arg2:T385	
R274	supports Arg1:T387 Arg2:T388	
R275	supports Arg1:T390 Arg2:T389	
T391	own_claim 45538 45597	we will obtain a v which is consistent with our constraints
T392	data 45458 45513	I − hW ∂v ∂f − h 2 W ∂x ∂f v = hW f 0 + h ∂x ∂f v 0 + z
T393	data 45417 45425	we solve
T394	data 45531 45536	for v
R276	parts_of_same Arg1:T394 Arg2:T392	
R277	parts_of_same Arg1:T392 Arg2:T393	
R278	supports Arg1:T394 Arg2:T391	
R279	supports Arg1:T389 Arg2:T391	
T395	own_claim 45660 45771	partially constrained particles will have a v i whose component in the constrained direction(s) is equal to z i
T396	own_claim 45599 45651	Completely constrained particles will have v i = z i
R280	supports Arg1:T391 Arg2:T396	
R281	supports Arg1:T391 Arg2:T395	
T397	own_claim 45904 45935	it worked exactly as advertised
T398	data 45832 45888	We initially implemented constraints using equation (14)
R282	supports Arg1:T398 Arg2:T397	
T399	own_claim 45966 46055	we solved equation (14) using a direct method (Gaussian elimination) without any problems
T400	data 45941 45964	very small test systems
R283	supports Arg1:T400 Arg2:T399	
T401	own_claim 46077 46185	we planned to use the iterative, sparsity-exploiting CG method, which immediately presents us with a problem
T402	data 46061 46075	larger systems
R284	supports Arg1:T402 Arg2:T401	
T403	data 46187 46233	equation (14) is not a symmetric linear system
R285	supports Arg1:T403 Arg2:T401	
T404	data 46253 46316	neither is equation (6) unless all particles have the same mass
T405	background_claim 46340 46366	require symmetric matrices
T406	background_claim 46319 46329	CG methods
R286	parts_of_same Arg1:T405 Arg2:T406	
T407	own_claim 46370 46472	We could apply a CG method to the unsymmetric matrix of equation (14) by use of the “normal equations”
T408	own_claim 46478 46641	this involves multiplying the matrix of equation (14) with its transpose which doubles the cost of each iteration while squaring the condition number of the system
R287	supports Arg1:T407 Arg2:T408	
T409	data 46644 46646	14
R288	supports Arg1:T409 Arg2:T408	
T410	own_claim 46678 46763	We decided that using a CG method to solve the unsymmetric problem was not acceptable
R289	supports Arg1:T408 Arg2:T410	
T411	own_claim 46796 46849	applying a CG method to equation (6) is not difficult
R290	contradicts Arg1:T411 Arg2:T410	
T412	data 46859 46894	we can transform this equation to 6
T413	data 46775 46794	without constraints
R291	supports Arg1:T413 Arg2:T411	
R292	supports Arg1:T412 Arg2:T411	
T414	own_claim 46904 46958	they work best on positive definite symmetric matrices
T415	own_claim 47302 47358	we cannot apply the same transformation to equation (14)
T416	data 47368 47381	W is singular
R293	supports Arg1:T416 Arg2:T415	
T417	own_claim 47442 47476	we cannot multiply through by W −1
R294	supports Arg1:T416 Arg2:T417	
R295	supports Arg1:T417 Arg2:T415	
T418	own_claim 47479 47674	The solution to the problem of asymmetry is to modify the CG method so that it can operate on equation (15), while procedurally applying the constraints inherent in the matrix W at each iteration
R296	supports Arg1:T415 Arg2:T418	
R297	supports Arg1:T410 Arg2:T418	
T419	own_claim 48444 48522	these two conditions imply that unconstrained particles have r i close to zero
T420	own_claim 48530 48577	completely constrained particles have v i = z i
T421	own_claim 48632 48710	our modified CG method should produce the same result as the regular CG method
T422	data 48602 48630	no particles are constrained
T423	own_claim 48032 48103	our modified CG method will try to find v that satisfies two conditions
T424	own_claim 48128 48220	the component of r i in the particle’s unconstrained direction(s) will be made equal to zero
T425	own_claim 48307 48390	the component of v i in the particle’s constrained direction(s) will be exactly z i
T426	data 48290 48305	each particle i
T427	data 48111 48126	each particle i
R298	supports Arg1:T427 Arg2:T424	
R299	supports Arg1:T426 Arg2:T425	
R300	supports Arg1:T422 Arg2:T421	
R301	supports Arg1:T424 Arg2:T423	
R302	supports Arg1:T425 Arg2:T423	
R303	supports Arg1:T425 Arg2:T420	
R304	supports Arg1:T424 Arg2:T419	
R305	supports Arg1:T419 Arg2:T421	
R306	supports Arg1:T420 Arg2:T421	
T428	own_claim 64383 64429	The variance in the running times was under 5%
T429	own_claim 64431 64520	We doubt that simulators based on explicit integration methods could make a similar claim
T430	data 64184 64334	Using the stiffness parameters in figure 1 as a reference, we ran the simulation with those bend stiffnesses multiplied by 0.1, 1.0, 10, 100 and 1,000
R307	supports Arg1:T430 Arg2:T428	
T431	own_claim 64871 64999	This is slightly better than O(n 1.5 ) performance, which is in line with the convergence rates of the conjugate gradient method
T432	own_claim 65007 65040	for systems such as equation (18)
T433	data 65002 65004	14
R308	parts_of_same Arg1:T432 Arg2:T431	
R309	supports Arg1:T433 Arg2:T431	
T434	data 64749 64869	The running times were, respectively, 0.23 seconds/frame, 0.46 seconds/frame, 2.23 seconds/frame, and 10.3 seconds/frame
T435	data 64631 64747	We ran the simulation in figure 1 with cloth resolutions of 500, 899, 2,602 (shown in figure 1 ) and 7,359 particles
R310	supports Arg1:T434 Arg2:T431	
R311	supports Arg1:T435 Arg2:T431	
T436	own_claim 61259 61388	The methods introduced in all of the previous sections usually allow us to take sizeable steps forward, without loss of stability
T437	own_claim 61399 61475	there are still times when the step size must be reduced to avoid divergence
R312	contradicts Arg1:T437 Arg2:T436	
T438	background_claim 61599 61689	these methods tend to concentrate on the accuracy of the simulation, and not the stability
T439	background_claim 61477 61549	There are a large number of methods for altering the size of a time step
T440	data 61691 61729	Our goal is animation, not engineering
T441	own_claim 61736 61853	visually pleasing results, meaning a numerically stable solution, rather than overall accuracy, is the deciding voice
R313	supports Arg1:T440 Arg2:T441	
T442	own_claim 61855 61925	The trick is to recognize instability before you see it on your screen
T443	background_claim 61949 62064	Stiffness, and thus any potential instability, arises almost completely from the strong stretch forces in the cloth
T444	own_claim 62410 62434	Subtlety is not required
T445	own_claim 62449 62524	an unstable step invariably results in stretch changes that are quite large
T446	own_claim 62539 62554	easily detected
T447	own_claim 62530 62533	are
R314	parts_of_same Arg1:T446 Arg2:T447	
R315	supports Arg1:T445 Arg2:T447	
R316	supports Arg1:T447 Arg2:T444	
T448	own_claim 63226 63325	the simulator settles down to wasting only one out of every 40 steps in attempting too large a step
T449	own_claim 63327 63373	This method, though simple, has served us well
T450	data 63191 63224	the user chooses too large a step
R317	supports Arg1:T450 Arg2:T448	
T451	data 63118 63180	the simulator will try increasing the step size every 40 steps
R318	supports Arg1:T451 Arg2:T448	
T452	background_claim 49240 49286	We wholeheartedly refer the reader to Shewchuk
T453	background_claim 49295 49327	for information on the CG method
R319	parts_of_same Arg1:T453 Arg2:T452	
T454	data 49290 49292	14
R320	supports Arg1:T454 Arg2:T452	
T455	own_claim 49396 49503	the effect of the matrix W in equation (14) is to filter out velocity changes in the constrained directions
T456	own_claim 50761 50798	our stopping criterion should as well
T457	data 50700 50759	our constrained formulation ignores certain components of b
R321	supports Arg1:T457 Arg2:T456	
T458	own_claim 50803 50829	we add filtering to line 3
R322	supports Arg1:T456 Arg2:T458	
T459	own_claim 50885 50932	should not include error due to the constraints
T460	own_claim 50940 50973	we add filtering at lines 4 and 8
R323	supports Arg1:T459 Arg2:T460	
T461	own_claim 51195 51241	products involving P −1 are trivially computed
T462	data 51107 51191	We use a simple preconditioner P by making P be a diagonal matrix with P ii = 1/A ii
R324	supports Arg1:T462 Arg2:T461	
T463	own_claim 51296 51342	we doubt there is a large speedup to be gained
T464	own_claim 51243 51287	More elaborate preconditioners could be used
R325	contradicts Arg1:T463 Arg2:T464	
T465	own_claim 51503 51605	obvious questions are “does it work?” followed by “how does it compare with the unmodified CG method?”
T466	data 51489 51501	modified-pcg
R326	supports Arg1:T466 Arg2:T465	
T467	own_claim 51669 51730	our method always converges, which answers the first question
T468	data 51656 51667	in practice
R327	supports Arg1:T468 Arg2:T467	
T469	background_claim 51606 51654	Proofs about CG methods are difficult in general
T470	own_claim 51890 51981	we did not notice any substantial change in the number of iterations required by the method
T471	own_claim 52013 52062	the two methods have similar convergence behavior
T472	data 51983 51994	Empirically
R328	supports Arg1:T472 Arg2:T471	
T473	data 51851 51888	we began using procedure modified-pcg
R329	supports Arg1:T473 Arg2:T470	
T474	data 51768 51844	we used a penalty method and applied the standard CG method to equation (15)
R330	supports Arg1:T474 Arg2:T471	
T475	own_claim 52098 52218	the running time is close to O(n 1.5 ), which is what unmodified CG would be expected to deliver on this sort of problem
T476	data 52221 52223	14
R331	supports Arg1:T476 Arg2:T475	
T477	data 52064 52083	Result in section 8
R332	supports Arg1:T477 Arg2:T475	
T478	own_claim 52362 52470	we need to know what the actual force of constraint is, in order to determine when to terminate a constraint
T479	own_claim 52308 52327	contact constraints
R333	parts_of_same Arg1:T478 Arg2:T479	
T480	own_claim 52486 52584	we need to know the constraint force actually exerted in order to model frictional forces properly
T481	own_claim 52599 52680	it is easy to add one more step to modified-pcg to determine the constraint force
T482	own_claim 52938 53060	we can compute constraint forces at the end of modified-pcg by performing one last matrixvector product to compute A v − b
T483	own_claim 52834 52930	e i is exactly the extra constraint force that must have been supplied to enforce the constraint
T484	data 52682 52823	When modified-pcg terminates, the residual error e = A v − b has the property that e i need not be close to zero if particle i is constrained
R334	supports Arg1:T484 Arg2:T483	
R335	supports Arg1:T483 Arg2:T482	
R336	supports Arg1:T482 Arg2:T481	
T485	own_claim 53191 53280	The particles’ accelerations are inherently dependent on one another through the matrix A
T486	data 53284 53297	equation (16)
R337	supports Arg1:T486 Arg2:T485	
T487	own_claim 53124 53188	the extra matrix-vector product to compute e really is necessary
T488	data 53063 53119	The vector r in modified-pcg is equal to filter(A v − b)
R338	supports Arg1:T488 Arg2:T487	
T489	own_claim 53315 53397	the correct approach to determing constraint release is combinatoric, as in Baraff
R339	supports Arg1:T485 Arg2:T489	
T490	data 53400 53401	2
R340	supports Arg1:T490 Arg2:T489	
T491	own_claim 53405 53443	We reject this approach as impractical
T492	data 53450 53468	the dimension of A
R341	supports Arg1:T492 Arg2:T491	
R342	supports Arg1:T486 Arg2:T491	
T493	own_claim 53479 53617	we allow contacts to release when the constraint force between a particle and a solid switches from a repulsive force to an attractive one
T494	own_claim 53632 53660	this has proven to work well
T495	data 53619 53630	In practice
R343	supports Arg1:T495 Arg2:T494	
T496	own_claim 53662 53697	Friction presents a similar problem
T497	background_claim 54159 54216	Much has been written about collision detection for cloth
T498	own_claim 54218 54297	we have nothing substantial to add to the subject of collision detection per se
T499	own_claim 55114 55132	a frictional force
T500	own_claim 55077 55093	The force is not
R344	parts_of_same Arg1:T500 Arg2:T499	
T501	own_claim 55230 55269	it reasonably emulates dynamic friction
T502	own_claim 55185 55219	it is in actuality a damping force
T503	own_claim 55141 55180	it is proportional to the slip velocity
R345	supports Arg1:T503 Arg2:T499	
R346	supports Arg1:T503 Arg2:T502	
R347	contradicts Arg1:T501 Arg2:T502	
T504	own_claim 55271 55342	Applying static friction forces to cloth contacts is far more difficult
T505	own_claim 55348 55383	is a problem we have not solved yet
T506	own_claim 55385 55480	The forces, and their derivatives with respect to position and velocity, are of course included
T507	data 55484 55497	equation (15)
R348	supports Arg1:T507 Arg2:T506	
T508	own_claim 56036 56109	Both cloth/cloth and cloth/solid collisions give rise to the same problem
T509	data 56119 56136	two contacts form
R349	supports Arg1:T509 Arg2:T508	
T510	own_claim 56434 56545	collisions resulting in a reasonably substantial interpenetration depth can occur between one step and the next
T511	data 56392 56432	our simulator proceeds in discrete steps
R350	supports Arg1:T511 Arg2:T510	
T512	own_claim 56556 56591	this situation needs to be remedied
T513	data 56138 56376	For both types of collisions, our detection algorithm reports an intersection, and then takes action to remedy the situation: either by enforcing a constraint (cloth/solid collisions) or by adding a penalty force (cloth/cloth) collisions.
R351	supports Arg1:T513 Arg2:T510	
R352	supports Arg1:T510 Arg2:T508	
T514	own_claim 56802 56835	the situation is more complicated
T515	data 56769 56791	cloth/solid collisions
T516	own_claim 56621 56658	this would not appear to be a problem
T517	data 56660 56763	the spring forces that are added work to counter the colliding velocities and then push the cloth apart
T518	data 56597 56619	cloth/cloth collisions
R353	supports Arg1:T518 Arg2:T516	
R354	supports Arg1:T515 Arg2:T514	
R355	supports Arg1:T517 Arg2:T516	
T519	own_claim 57114 57134	This is unacceptable
T520	own_claim 57018 57112	the cloth particle will continue to remain embedded somewhere below the solid object’s surface
T521	data 56840 57016	we simply enforce a constraint which causes the colliding cloth particle to have a velocity consistent with the solid object’s velocity, and continue to enforce that constraint
R356	supports Arg1:T521 Arg2:T520	
R357	supports Arg1:T520 Arg2:T519	
R358	supports Arg1:T519 Arg2:T514	
T522	own_claim 57136 57182	One solution is to use Baumgarte stabilization
T523	data 57185 57187	18
R359	supports Arg1:T523 Arg2:T522	
T524	background_claim 57192 57348	which schedules the particle’s acceleration so that the position and velocity error of the particle with respect to the surface decay asymptotically to zero
R360	supports Arg1:T523 Arg2:T524	
R361	supports Arg1:T524 Arg2:T522	
T525	own_claim 57391 57407	found it lacking
T526	data 57350 57385	We experimented with this technique
R362	supports Arg1:T526 Arg2:T525	
T527	own_claim 57424 57485	a fast rise to the surface was prone to noise and “jumpiness”
R363	supports Arg1:T526 Arg2:T527	
R364	supports Arg1:T527 Arg2:T525	
T528	own_claim 57487 57556	this could be eliminated, but at the cost of decreasing the step size
T529	own_claim 57558 57610	A slower rise to the surface caused visual artifacts
R365	supports Arg1:T526 Arg2:T529	
T530	own_claim 58125 58187	simply changing particle positions produced disastrous results
T531	own_claim 58028 58074	it should not interfere with a one-step solver
T532	own_claim 57893 57996	this would be problematic when using a multi-step differential equation solver which expects continuity
T533	data 58006 58025	a RungeKutta method
T534	data 58083 58108	the backward Euler method
R366	supports Arg1:T534 Arg2:T531	
R367	supports Arg1:T533 Arg2:T532	
T535	own_claim 57612 57639	We tried a simpler solution
T536	data 57641 57885	when intersections occurred, rather than wait for a scheduled constraint or a penalty force to eliminate the intersection, we simply altered the positions of the cloth particles, effecting an instantaneous (and discontinuous) change in position
R368	supports Arg1:T536 Arg2:T535	
R369	supports Arg1:T535 Arg2:T530	
T537	own_claim 58385 58460	This resulted in visibly “jumpy” behavior of the cloth in localized regions
T538	data 58256 58383	altering particle positions arbitrarily introduced excessively large deformation energies in an altered particle’s neighborhood
T539	background_claim 58189 58250	The stretch energy term in a cloth system is extremely strong
R370	supports Arg1:T539 Arg2:T537	
R371	supports Arg1:T538 Arg2:T537	
R372	supports Arg1:T537 Arg2:T530	
T540	own_claim 58678 58781	the ability to make arbitrary small changes in a particle’s position continued to attract our attention
T541	own_claim 58783 58869	The entire process of implicit integration can be considered to be a filtering process
T542	data 58873 58874	7
R373	supports Arg1:T542 Arg2:T541	
T543	own_claim 58901 59022	a mechanism for filtering energy changes caused by displacing particles might make position alteration a viable technique
T544	own_claim 59051 59109	some sort of extra implicit step could be used as a filter
T545	own_claim 59115 59196	forming and solving an additional linear system at each step seemed too expensive
T546	own_claim 59207 59293	we can make use of the filtering effect of implicit integration without any extra work
R374	contradicts Arg1:T545 Arg2:T544	
T547	own_claim 59915 59962	we simply modify the top row of equation (4) to
T548	own_claim 59995 60021	x i = h(v 0i + v i ) + y i
T549	own_claim 59880 59913	This presents an obvious solution
R375	supports Arg1:T547 Arg2:T549	
T550	own_claim 59721 59803	the particle’s neighbors receive no advance notification of the change in position
T551	data 59805 59878	they are confronted with the alteration at the beginning of the next step
R376	supports Arg1:T551 Arg2:T550	
T552	own_claim 59650 59709	changing positions after a step has been taken doesn’t work
R377	supports Arg1:T550 Arg2:T552	
R378	parts_of_same Arg1:T548 Arg2:T547	
R379	supports Arg1:T550 Arg2:T549	
T553	own_claim 60232 60266	we must follow this change through
T554	data 60194 60230	modified the top row of equation (4)
R380	supports Arg1:T554 Arg2:T553	
T555	own_claim 60442 60499	M − h ∂v ∂f − h 2 ∂x ∂f v = h f 0 + h ∂x ∂f v 0 + ∂x ∂f y
R381	supports Arg1:T553 Arg2:T555	
T556	data 60274 60287	equation (17)
T557	data 60306 60329	derivation of section 3
T558	data 60338 60372	symmetric transform from section 5
R382	supports Arg1:T556 Arg2:T555	
R383	supports Arg1:T557 Arg2:T555	
R384	supports Arg1:T558 Arg2:T555	
T559	own_claim 60519 60679	This modification gives us complete control over both the position and velocity of a constrained particle in just one step, without any extra computational cost
R385	supports Arg1:T555 Arg2:T559	
T560	own_claim 60844 60924	We can also add correction terms to particles involved in cloth/cloth collisions
T561	own_claim 60926 61051	Without a constraint on those particles’ velocities there is no guarantee that they will go exactly where we want in one step
T562	own_claim 61057 61193	the ability to induce sizeable jumps in position without excessively stiff spring forces adds greatly to the stability of the simulation
R386	supports Arg1:T560 Arg2:T562	
