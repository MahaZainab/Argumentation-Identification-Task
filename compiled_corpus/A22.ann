T1	background_claim 2137 2257	The fundamental problem of tracking a surface as it is advected by some velocity field arises frequently in applications
T2	data 2266 2288	surface reconstruction
T3	data 2290 2308	image segmentation
T4	data 2314 2330	fluid simulation
R1	supports Arg1:T2 Arg2:T1	
R2	supports Arg1:T3 Arg2:T1	
R3	supports Arg1:T4 Arg2:T1	
T5	background_claim 2332 2538	Unfortunately, the na ̈ ive approach of simply advecting the vertices of a polygonal mesh, or other explicit representation of the surface, quickly encounters problems such as tangling and self-intersection
T6	background_claim 2549 2568	a family of methods
T7	background_claim 2598 2637	has been developed for surface tracking
R4	parts_of_same Arg1:T6 Arg2:T7	
T8	data 2579 2596	level-set methods
R5	supports Arg1:T8 Arg2:T6	
T9	background_claim 2639 2751	These methods represent the surface implicitly as the zero set of a scalar field defined over the problem domain
T10	background_claim 2754 2781	The methods are widely used
T11	background_claim 2787 2799	the texts by
T12	background_claim 2894 2940	provide an excellent introduction to the topic
R6	parts_of_same Arg1:T11 Arg2:T12	
T13	data 2801 2808	Sethian
T14	data 2810 2814	1999
R7	parts_of_same Arg1:T13 Arg2:T14	
T15	data 2820 2836	Osher and Fedkiw
T16	data 2838 2842	2003
R8	parts_of_same Arg1:T15 Arg2:T16	
R9	supports Arg1:T13 Arg2:T11	
R10	supports Arg1:T15 Arg2:T11	
T17	data 2850 2869	Osher and Sethian’s
T18	data 2871 2875	1988
R11	parts_of_same Arg1:T17 Arg2:T18	
R12	supports Arg1:T17 Arg2:T11	
T19	background_claim 2942 3150	One of the key issues that distinguishes various level-set and similar approaches is the representation of the scalar field, which must capture whatever surface properties are important to a given application
T20	own_claim 3168 3264	we present a surface tracking method that explicitly represents the surface as a set of polygons
T21	own_claim 3346 3407	we update the surface in time with an implicit representation
T22	data 3409 3455	an advected signed-distance function, ψ, whose
R13	supports Arg1:T22 Arg2:T21	
T23	data 4888 4916	zero set defines the surface
R14	parts_of_same Arg1:T23 Arg2:T22	
T24	own_claim 4918 5000	A new polygonal surface is generated by contouring or extracting the zero set of ψ
T25	own_claim 5229 5368	Using adaptive octree data structures, we can efficiently and reliably construct the new surface and corresponding signed-distance function
T26	background_claim 5370 5443	The theoretical framework for this method comes from a series of articles
T27	background_claim 5488 5563	that described and analyzed a method for contour tracking in two dimensions
R15	parts_of_same Arg1:T26 Arg2:T27	
T28	data 5447 5453	Strain
T29	data 5455 5460	1999b
T30	data 5462 5467	1999c
T31	data 5469 5474	1999a
T32	data 5476 5480	2000
T33	data 5482 5486	2001
R16	parts_of_same Arg1:T28 Arg2:T29	
R17	parts_of_same Arg1:T28 Arg2:T30	
R18	parts_of_same Arg1:T28 Arg2:T31	
R19	parts_of_same Arg1:T28 Arg2:T32	
R20	parts_of_same Arg1:T28 Arg2:T33	
R21	supports Arg1:T28 Arg2:T26	
T34	data 5659 5702	going from twoto three-dimensional problems
T35	background_claim 5571 5653	the semi-Lagrangian procedure for backward advection does not change significantly
R22	supports Arg1:T34 Arg2:T35	
T36	background_claim 5704 5777	significant surface tracking issues arise when moving to three dimensions
R23	contradicts Arg1:T35 Arg2:T36	
T37	own_claim 5851 5977	demonstrates how semi-Lagrangian surface contouring can be useful for animating the complex and interesting behavior of fluids
T38	own_claim 5779 5791	This article
R24	parts_of_same Arg1:T38 Arg2:T37	
T39	own_claim 5979 6075	One of the primary advantages of this method is that it enables tracking surface characteristics
T40	data 6085 6090	color
T41	data 6094 6113	texture coordinates
R25	supports Arg1:T40 Arg2:T39	
R26	supports Arg1:T41 Arg2:T39	
T42	own_claim 6115 6260	These properties can be easily stored directly on the polygonal mesh and efficiently mapped onto the new surface during semi-Lagrangian advection
T43	own_claim 6262 6337	The explicit surface representation also facilitates other common operation
T44	data 6348 6357	rendering
R27	supports Arg1:T44 Arg2:T43	
T45	own_claim 6365 6460	reconstruction from a scalar function allows operations that rely on an implicit representation
T46	own_claim 6471 6626	the method produces detailed, well-defined surfaces that are suitable for realistic animation and that do not jitter or exhibit other undesirable behaviors
T47	own_claim 6674 6790	Our method pulls together solutions to a number of well-studied problems to arrive at a method for tracking surfaces
T48	background_claim 7113 7169	the topic has received a significant amount of attention
T49	data 7063 7111	surface tracking arises in a variety of contexts
R28	supports Arg1:T49 Arg2:T48	
T50	background_claim 7173 7306	Even in the limited context of fluid animation, there has been a great deal of excellent work on simulating fluids with free surfaces
T51	data 7319 7337	Foster and Metaxas
T52	data 7339 7343	1996
R29	parts_of_same Arg1:T52 Arg2:T51	
R30	supports Arg1:T51 Arg2:T50	
T53	background_claim 7569 7671	The methods available for tracking free surfaces of liquids can be roughly sorted into four categories
T54	data 7346 7363	Foster and Fedkiw
T55	data 7365 7369	2001
R31	parts_of_same Arg1:T55 Arg2:T54	
R32	supports Arg1:T54 Arg2:T50	
T56	background_claim 7673 7690	level-set methods
R33	supports Arg1:T56 Arg2:T53	
T57	data 7372 7386	Enright et al.
R34	supports Arg1:T57 Arg2:T50	
T58	data 7388 7393	2002b
R35	parts_of_same Arg1:T58 Arg2:T57	
T59	data 7396 7410	Carlson et al.
T60	data 7412 7416	2002
T61	background_claim 7692 7714	particle-based methods
R36	parts_of_same Arg1:T60 Arg2:T59	
T62	data 7418 7422	2004
R37	supports Arg1:T61 Arg2:T53	
R38	parts_of_same Arg1:T62 Arg2:T59	
T63	background_claim 7716 7742	particle level-set methods
R39	supports Arg1:T59 Arg2:T50	
T64	data 7426 7440	Losasso et al.
T65	data 7442 7446	2004
R40	parts_of_same Arg1:T65 Arg2:T64	
R41	supports Arg1:T64 Arg2:T50	
T66	data 7449 7464	Goktekin et al.
R42	supports Arg1:T63 Arg2:T53	
T67	data 7466 7470	2004
T68	background_claim 7748 7774	semi-Lagrangian contouring
R43	supports Arg1:T68 Arg2:T53	
R44	parts_of_same Arg1:T67 Arg2:T66	
R45	supports Arg1:T66 Arg2:T50	
T69	data 7473 7485	Hong and Kim
T70	data 7487 7491	2005
T71	data 7494 7505	Wang et al.
T72	data 7507 7511	2005
T73	data 7514 7531	Guendelman et al.
T74	data 7533 7537	2005
T75	data 7545 7560	Zhu and Bridson
T76	data 7562 7566	2005
R46	parts_of_same Arg1:T70 Arg2:T69	
R47	parts_of_same Arg1:T72 Arg2:T71	
R48	parts_of_same Arg1:T74 Arg2:T73	
R49	parts_of_same Arg1:T76 Arg2:T75	
R50	supports Arg1:T69 Arg2:T50	
R51	supports Arg1:T71 Arg2:T50	
R52	supports Arg1:T73 Arg2:T50	
R53	supports Arg1:T75 Arg2:T50	
T77	background_claim 7801 7938	Many of the most successful solutions to the surface tracking problem are based on level-set methods, which were originally introduced by
T78	data 7940 7957	Osher and Sethian
T79	data 7959 7963	1988
R54	parts_of_same Arg1:T79 Arg2:T78	
R55	supports Arg1:T78 Arg2:T77	
T80	own_claim 7966 8040	A complete review of level-set methods is beyond the scope of this article
T81	own_claim 8046 8083	we recommend the excellent surveys by
R56	supports Arg1:T80 Arg2:T81	
T82	data 8085 8092	Sethian
T83	data 8104 8120	Osher and Fedkiw
T84	data 8094 8098	1999
T85	data 8122 8126	2003
R57	parts_of_same Arg1:T84 Arg2:T82	
R58	parts_of_same Arg1:T85 Arg2:T83	
R59	supports Arg1:T82 Arg2:T81	
R60	supports Arg1:T83 Arg2:T81	
T86	background_claim 8393 8496	By using this implicit representation, level-set methods avoid dealing with complex topological changes
T87	background_claim 8129 8273	Level-set methods represent a surface as the zero set of a scalar function which is updated over time by solving a partial differential equation
T88	data 8288 8306	level-set equation
R61	supports Arg1:T88 Arg2:T87	
T89	background_claim 8308 8391	This equation relates change of the scalar function to an underlying velocity field
T90	background_claim 8507 8593	the scalar function is defined and maintained in the embedding three-dimensional space
R62	contradicts Arg1:T90 Arg2:T86	
T91	background_claim 8644 8736	In practice, scalar function values need only be accurately maintained very near the surface
T92	background_claim 8738 8813	resulting in a cost that is roughly linear in the complexity of the surface
R63	supports Arg1:T91 Arg2:T92	
T93	background_claim 8815 8924	One difficulty with level-set methods is that they generally require very high-order conservation-law solvers
T94	background_claim 8933 8999	fast semi-Lagrangian methods have been shown to work in some cases
R64	contradicts Arg1:T94 Arg2:T93	
T95	data 9002 9014	Strain 1999b
T96	data 9016 9035	Enright et al. 2005
R65	supports Arg1:T95 Arg2:T94	
R66	supports Arg1:T96 Arg2:T94	
T97	background_claim 9038 9193	The most significant drawback to using level-set methods to track liquid surfaces is their tendency to lose volume in underresolved, high-curvature regions
T98	background_claim 9227 9286	an excellent discussion of the reasons for this volume loss
T99	data 9199 9213	Enright et al.
T100	data 9215 9220	2002a
R67	parts_of_same Arg1:T99 Arg2:T100	
R68	supports Arg1:T100 Arg2:T98	
T101	own_claim 9460 9529	Like us, they used adaptive grid structures to store the scalar field
T102	background_claim 9540 9597	they used a two-level structure rather than a full octree
T103	background_claim 9599 9672	They also used semi-Lagrangian methods to update their level-set function
T104	background_claim 9322 9458	built a sculpting system using a level-set surface representation which could be manipulated by a user with a variety of sculpting tools
T105	data 9288 9313	Bærentzen and Christensen
T106	data 9315 9319	2002
R69	parts_of_same Arg1:T105 Arg2:T106	
R70	supports Arg1:T106 Arg2:T104	
R71	contradicts Arg1:T102 Arg2:T101	
T107	background_claim 9761 9819	they interpolated distance values stored on a regular grid
T108	own_claim 9827 9916	our explicit surface representation allows us to compute exact distances near the surface
R72	contradicts Arg1:T108 Arg2:T107	
T109	data 9688 9759	evaluating the distance function after the semi-Lagrangian path tracing
R73	supports Arg1:T109 Arg2:T107	
T110	background_claim 9946 10036	coupled volume-of-fluid and level-set methods to model droplet dynamics in ink-jet devices
T111	data 9918 9937	Sussman and Puckett
T112	data 9939 9943	2000
R74	parts_of_same Arg1:T111 Arg2:T112	
R75	supports Arg1:T112 Arg2:T110	
T113	background_claim 10080 10157	techniques represent the surface by storing, in each voxel, a volume fraction
T114	background_claim 10038 10053	Volume-of-fluid
R76	parts_of_same Arg1:T114 Arg2:T113	
T115	data 10056 10077	Hirt and Nichols 1981
R77	supports Arg1:T115 Arg2:T114	
T116	data 10158 10204	the proportion of the voxel filled with liquid
R78	supports Arg1:T116 Arg2:T113	
T117	background_claim 10206 10265	Any cell whose fraction is not one or zero contains surface
T118	background_claim 10267 10398	Unfortunately, this representation does not admit accurate curvature estimates, which are essential to surface tension computations
T119	background_claim 10409 10488	accurate curvature estimates are easily computed from level-set representations
R79	contradicts Arg1:T119 Arg2:T118	
T120	background_claim 10496 10603	the authors combined volume-of-fluid and level-set representations to model surface tension in ink droplets
T121	background_claim 10605 10721	Some volume-of-fluid methods build an explicit surface representation from the volume fractions stored in each voxel
R80	supports Arg1:T119 Arg2:T120	
T122	own_claim 10723 10830	The key difference between our method and volume-of-fluid methods is that we never compute volume fractions
T123	own_claim 10841 10932	our explicit representation is generated by contouring an advected signed-distance function
T124	background_claim 10964 10987	A number of researchers
T125	background_claim 11223 11260	have used particles to track surfaces
R81	parts_of_same Arg1:T124 Arg2:T125	
T127	data 10989 11012	Terzopoulos et al. 1989
T128	data 11014 11038	Desbrun and Gascuel 1995
T129	data 11040 11063	Foster and Metaxas 1996
T130	data 11065 11086	Desbrun and Cani 1996
T131	data 11088 11109	Cani and Desbrun 1997
R83	supports Arg1:T127 Arg2:T124	
R84	supports Arg1:T128 Arg2:T124	
R85	supports Arg1:T129 Arg2:T124	
R86	supports Arg1:T130 Arg2:T124	
T132	data 11111 11128	Stora et al. 1999
T133	data 11130 11152	M uller  ̈ et al. 2003
T134	data 11154 11158	2004
R82	parts_of_same Arg1:T133 Arg2:T134	
T126	data 11160 11180	Premo ze et al. 2003
R87	supports Arg1:T131 Arg2:T124	
R88	supports Arg1:T132 Arg2:T124	
R89	supports Arg1:T133 Arg2:T124	
R90	supports Arg1:T126 Arg2:T124	
T135	data 11182 11202	Zhu and Bridson 2005
T136	data 11204 11221	Pauly et al. 2005
R91	supports Arg1:T135 Arg2:T124	
R92	supports Arg1:T136 Arg2:T124	
T137	background_claim 11262 11413	In many of these methods, the simulation elements are particles, which are already being tracked throughout the volume of the deforming liquid or solid
T138	background_claim 11719 11787	used particle positions and velocities to guide a level-set solution
T139	data 11671 11686	Premo ze et al.
T140	data 11688 11692	2003
R93	parts_of_same Arg1:T139 Arg2:T140	
R94	supports Arg1:T140 Arg2:T138	
T141	data 11789 11803	Mueller et al.
T142	data 11805 11809	2004
R95	parts_of_same Arg1:T141 Arg2:T142	
T143	data 11815 11827	Pauly et al.
T144	background_claim 11836 11858	used special particles
T145	background_claim 11876 11900	to represent the surface
R96	parts_of_same Arg1:T144 Arg2:T145	
T146	data 11829 11833	2005
R97	parts_of_same Arg1:T143 Arg2:T146	
R98	supports Arg1:T142 Arg2:T144	
R99	supports Arg1:T146 Arg2:T144	
T147	data 11867 11874	surfels
R100	supports Arg1:T147 Arg2:T144	
T148	background_claim 11902 11952	Surfels store a surface normal as well as position
T149	background_claim 11957 12020	there are generally many more surfels than simulation particles
T150	background_claim 12022 12133	The principal drawback of these methods is that generating high-quality time-coherent surfaces can be difficult
T151	data 12135 12213	directly visualizing the particles is insufficient for high-quality animations
R101	supports Arg1:T151 Arg2:T150	
T152	data 12215 12330	methods which convert the particles to some other representation on a per-frame basis often lack temporal coherence
R102	supports Arg1:T152 Arg2:T150	
T153	data 12336 12442	methods which must run sequentially through the frames or run during the simulation are often quite costly
R103	supports Arg1:T153 Arg2:T150	
T154	background_claim 12444 12526	Additional difficulties arise when trying to ensure a good sampling of the surface
T155	background_claim 12562 12609	To address the volume loss of level-set methods
T156	background_claim 12659 12679	built on the work of
T157	background_claim 12707 12744	to develop particle level-set methods
R104	parts_of_same Arg1:T155 Arg2:T156	
R105	parts_of_same Arg1:T156 Arg2:T157	
T158	data 12611 12637	Enright and his colleagues
T159	data 12653 12657	2005
T160	data 12646 12651	2002b
T161	data 12639 12644	2002a
R106	parts_of_same Arg1:T161 Arg2:T158	
R107	parts_of_same Arg1:T160 Arg2:T158	
R108	parts_of_same Arg1:T159 Arg2:T158	
R109	supports Arg1:T158 Arg2:T155	
T162	data 12681 12698	Foster and Fedkiw
T163	data 12700 12704	2001
R110	parts_of_same Arg1:T163 Arg2:T162	
R111	supports Arg1:T162 Arg2:T156	
T164	background_claim 12746 12880	These methods track the characteristics of the fluid flow with Lagrangian particles, which are then used to fix the level-set solution
T165	background_claim 12882 12943	essentially increasing the effective resolution of the method
R112	supports Arg1:T164 Arg2:T165	
T166	background_claim 12955 13008	these methods have been extended to work with octrees
T167	background_claim 13055 13105	allowing for very high-resolution surface tracking
R113	parts_of_same Arg1:T166 Arg2:T167	
T168	data 13011 13030	Enright et al. 2005
T169	data 13032 13051	Losasso et al. 2004
R114	supports Arg1:T168 Arg2:T166	
R115	supports Arg1:T169 Arg2:T166	
T170	background_claim 13107 13201	These methods represent the current state of the art on tracking liquid surfaces for animation
T171	background_claim 13207 13229	do have some drawbacks
R116	contradicts Arg1:T171 Arg2:T170	
T172	background_claim 13440 13544	the method is extremely susceptible to high-frequency temporally incoherent perturbations of the surface
R117	supports Arg1:T172 Arg2:T171	
T173	data 13355 13438	there is no guarantee that the same particle will be chosen at subsequent timesteps
R118	supports Arg1:T173 Arg2:T172	
T174	background_claim 13546 13706	The artifacts are most noticeable when the surface thins out below the grid resolution and particles happen to be near some of the sample points, but not others
T175	background_claim 13714 13767	the method has a large number of parameters and rules
T176	background_claim 13838 13900	which need to be decided, often in an application-specific way
R119	parts_of_same Arg1:T176 Arg2:T175	
T177	data 13777 13809	the number of particles per cell
T178	data 13814 13836	the reseeding strategy
R120	supports Arg1:T177 Arg2:T175	
R121	supports Arg1:T178 Arg2:T175	
T179	background_claim 14026 14038	applications
T180	background_claim 13911 14011	the method tends to produce very smooth surfaces with very little detail, which is desirable in some
R122	parts_of_same Arg1:T180 Arg2:T179	
T181	background_claim 14065 14217	the particle level-set methods have been very successful and represent a significant step forward in the area of surface tracking for liquid simulations
R123	contradicts Arg1:T181 Arg2:T171	
T182	background_claim 14304 14444	has written a series of articles building a theoretical framework culminating in the formulation of surface tracking as a contouring problem
T183	data 14263 14269	Strain
T184	background_claim 14446 14540	He demonstrated his semi-Lagrangian contouring method on a variety of two-dimensional examples
T185	data 14271 14276	1999b
T186	data 14278 14283	1999c
T187	data 14285 14290	1999a
T188	data 14292 14296	2000
T189	data 14298 14302	2001
R124	parts_of_same Arg1:T185 Arg2:T183	
R125	parts_of_same Arg1:T186 Arg2:T183	
R126	parts_of_same Arg1:T187 Arg2:T183	
R127	parts_of_same Arg1:T188 Arg2:T183	
R128	parts_of_same Arg1:T189 Arg2:T183	
R129	supports Arg1:T183 Arg2:T182	
T190	own_claim 14542 14588	Our method is based on the method presented by
T191	own_claim 14610 14713	with variations and extensions to deal with problems that arise in three-dimensional computer animation
T192	data 14590 14596	Strain
T193	data 14598 14602	2001
R130	parts_of_same Arg1:T192 Arg2:T193	
R131	supports Arg1:T192 Arg2:T190	
R132	contradicts Arg1:T191 Arg2:T190	
T194	own_claim 14721 14783	our method bears a number of similarities to level-set methods
T195	own_claim 14788 14850	takes advantage of many techniques developed for those methods
T196	own_claim 14852 14902	we are not directly solving the level-set equation
R133	contradicts Arg1:T196 Arg2:T195	
R134	contradicts Arg1:T196 Arg2:T194	
T197	own_claim 14904 15022	By formulating surface tracking as a contouring problem, we avoid many of the issues that complicate level-set methods
T198	own_claim 15039 15126	we do not have the same volume loss issues which prompted the particle levelset methods
T199	own_claim 15134 15170	we do not explicitly conserve volume
T200	own_claim 15172 15306	our semi-Lagrangian path tracing tends to conserve volume in the same way as the Lagrangian particles in the particle level-set method
R135	contradicts Arg1:T200 Arg2:T199	
R136	supports Arg1:T200 Arg2:T198	
T201	own_claim 15651 15771	The octree structure we use to build and index the polygonal mesh is quite similar to adaptively sampled distance fields
T202	data 15773 15792	Frisken et al. 2000
R137	supports Arg1:T202 Arg2:T201	
T203	own_claim 15914 16070	The key difference between adaptively sampled distance fields and our surface representation is that we store a polygon mesh in addition to distance samples
T204	background_claim 15795 15912	These structures adaptively sample distance fields according to local detail and store samples in a spatial hierarchy
T205	own_claim 16162 16235	Additionally, our splitting criterion is different from that presented by
T206	data 16237 16251	Frisken et al.
T207	data 16253 16257	2000
R138	parts_of_same Arg1:T207 Arg2:T206	
R139	supports Arg1:T206 Arg2:T205	
T208	background_claim 16260 16359	An alternative structure for storing narrow-band level-set functions is the dynamic tubular grid of
T209	data 16361 16379	Nielsen and Museth
T210	data 16381 16385	2006
R140	parts_of_same Arg1:T210 Arg2:T209	
R141	supports Arg1:T209 Arg2:T208	
T211	background_claim 16388 16451	This structure can be combined with run-length encoding schemes
T212	data 16453 16472	Houston et al. 2006
R142	supports Arg1:T212 Arg2:T211	
T213	background_claim 16476 16559	providing extremely compact, high-resolution representations of level-set functions
R143	supports Arg1:T211 Arg2:T213	
T214	background_claim 16620 16726	they are able to exploit cache coherence to provide extremely fast run times for most level-set operations
T215	own_claim 16567 16618	the asymptotic times for their structure match ours
T216	own_claim 16728 16827	Integrating the methods presented here with this data structure is a promising area for future work
R144	contradicts Arg1:T214 Arg2:T215	
T217	own_claim 16914 16967	we formulate surface tracking as a contouring problem
T218	background_claim 16969 17034	The contouring problem has been well studied in computer graphics
T219	background_claim 17039 17081	a number of approaches have been suggested
T220	background_claim 17141 17163	was first presented by
T221	background_claim 17187 17221	and later named and popularized by
R145	parts_of_same Arg1:T220 Arg2:T221	
T222	data 17165 17178	Wyvill et al.
T223	data 17180 17184	1986
R146	parts_of_same Arg1:T222 Arg2:T223	
R147	supports Arg1:T222 Arg2:T220	
T224	data 17223 17241	Lorensen and Cline
T225	background_claim 17084 17133	The oldest and most widely used is marching cubes
T226	data 17243 17247	1987
R148	parts_of_same Arg1:T224 Arg2:T226	
R149	supports Arg1:T224 Arg2:T221	
T227	background_claim 17250 17319	Marching cubes suffers from a tendency to create ill-shaped triangles
T228	background_claim 17321 17376	This problem is fixed to some degree by dual contouring
T229	background_claim 17396 17487	which also provides adaptive contouring and an elegant means of preserving sharp boundaries
R150	parts_of_same Arg1:T228 Arg2:T229	
T230	data 17378 17392	Ju et al. 2002
R151	supports Arg1:T230 Arg2:T228	
T231	background_claim 17489 17614	Dual contouring depends on normal estimates at edge crossings and is very sensitive to inaccuracies in these normal estimates
T232	own_claim 17616 17719	Unfortunately, in our method we do not have accurate normal information until after the contouring step
T233	data 17726 17751	we have the triangle mesh
R152	supports Arg1:T233 Arg2:T232	
T234	background_claim 17797 17912	presented a contouring technique which uses Delaunay triangulation methods to generate provably good triangulations
T235	data 17768 17788	Boissonnat and Oudot
T236	data 17790 17794	2003
R153	parts_of_same Arg1:T236 Arg2:T235	
R154	supports Arg1:T236 Arg2:T234	
T237	background_claim 17923 18019	this method appears to be prohibitively expensive for something which must run at every timestep
T238	background_claim 18021 18066	Yet another alternative is marching triangles
T239	background_claim 18091 18166	which takes a surface-based rather than volume-based approach to contouring
R155	parts_of_same Arg1:T238 Arg2:T239	
T240	data 18069 18087	Hilton et al. 1996
R156	supports Arg1:T240 Arg2:T238	
T241	background_claim 18168 18310	Marching triangles requires significantly less computation time and fewer triangles, and produces higher-quality triangles than marching cubes
T242	background_claim 18327 18440	marching triangles is not guaranteed to produce closed, manifold meshes in the presence of sharp or thin features
T243	background_claim 18667 18733	Semi-Lagrangian methods have been widely used in computer graphics
T244	background_claim 18778 18846	to solve the nonlinear advection term of the Navier-Stokes equations
R157	parts_of_same Arg1:T243 Arg2:T244	
T245	data 18771 18775	1999
T246	data 18765 18769	Stam
R158	parts_of_same Arg1:T246 Arg2:T245	
R159	supports Arg1:T246 Arg2:T243	
T247	own_claim 18848 18916	These methods provide the foundation for our surface tracking method
T248	own_claim 19007 19037	Our discussion follows that of
T249	data 19039 19045	Strain
T250	data 19047 19052	1999b
R160	parts_of_same Arg1:T250 Arg2:T249	
R161	supports Arg1:T249 Arg2:T248	
T251	background_claim 19761 19851	This observation forms the basis of the backward characteristic or CIR scheme developed by
T252	data 19852 19879	Courant, Isaacson, and Rees
T253	data 19881 19885	1952
R162	parts_of_same Arg1:T253 Arg2:T252	
R163	supports Arg1:T252 Arg2:T251	
T254	background_claim 19889 19933	which is the simplest semi-Lagrangian scheme
R164	parts_of_same Arg1:T251 Arg2:T254	
T255	data 20447 20458	linear PDEs
T256	data 20468 20480	Equation (1)
T257	background_claim 20482 20519	the Lax-Richtmyer equivalence theorem
T258	background_claim 20537 20592	guarantees that CIR will converge to the exact solution
T259	data 20522 20534	LeVeque 1990
R165	supports Arg1:T256 Arg2:T255	
R166	supports Arg1:T255 Arg2:T257	
R167	supports Arg1:T259 Arg2:T257	
R168	parts_of_same Arg1:T257 Arg2:T258	
T260	data 20596 20604	t, x → 0
T261	data 20608 20635	it is stable and consistent
R169	supports Arg1:T261 Arg2:T260	
R170	supports Arg1:T260 Arg2:T258	
T262	background_claim 20637 20693	The stability properties of the CIR scheme are excellent
T263	own_claim 20776 20873	unconditional stability is guaranteed in any norm where the interpolation does not increase norms
T264	own_claim 20695 20770	Each new value φ(x, t n+1 ) is a single interpolated value of φ at time t n
R171	supports Arg1:T264 Arg2:T263	
T265	data 20888 20957	CIR with linear interpolation is unconditionally stable in the 2-norm
R172	supports Arg1:T265 Arg2:T263	
T266	background_claim 20971 21082	semi-Lagrangian schemes satisfy the CFL condition by shifting the stencil, rather than restricting the timestep
T267	own_claim 21089 21147	information propagates over long distances in one timestep
R173	supports Arg1:T266 Arg2:T267	
T268	own_claim 21584 21610	CIR is consistent to O( t)
T269	data 21614 21648	a condition t ≥ O( x) is satisfied
R174	supports Arg1:T269 Arg2:T268	
T270	own_claim 21702 21740	This condition is extremely convenient
T271	data 21750 21830	t = O( x) balances time and space resolution in this first-order accurate scheme
R175	supports Arg1:T271 Arg2:T270	
T272	own_claim 22707 22754	CIR still converges when the solution is smooth
T273	data 22691 22705	nonlinear PDEs
R176	supports Arg1:T273 Arg2:T272	
T274	own_claim 22760 22830	nonsmooth shock solutions of conservation laws move at the wrong speed
T275	data 22839 22870	CIR is not in conservative form
R177	supports Arg1:T275 Arg2:T274	
T276	data 22878 22912	level-set solutions have no shocks
T277	own_claim 22914 22959	CIR is a natural scheme for moving interfaces
R178	supports Arg1:T276 Arg2:T277	
T278	own_claim 23349 23409	would quickly encounter significant topological difficulties
T279	data 23298 23343	advect the mesh points through the flow field
R179	supports Arg1:T279 Arg2:T278	
T280	own_claim 23420 23504	we avoid topological issues by updating the surface using an implicit representation
T281	own_claim 23990 24147	One of the key differences between our method and other surface tracking methods is that we build an explicit representation of the surface at every timestep
T282	own_claim 24487 24558	The explicit representation provides our method with several advantages
T283	own_claim 24567 24632	it allows us to compute exact signeddistance values near the mesh
T284	own_claim 24642 24691	it allows us to store properties on mesh vertices
R180	supports Arg1:T283 Arg2:T282	
T285	own_claim 24739 24896	it allows us to take advantage of the many tools and algorithms which have been developed in computer graphics for manipulating and rendering triangle meshes
R181	supports Arg1:T284 Arg2:T282	
R182	supports Arg1:T285 Arg2:T282	
T286	own_claim 26794 26901	In solving this advection term, our method differs from the simple CIR scheme discussed earlier in two ways
T287	own_claim 26962 27002	we use a second-order Runge-Kutta scheme
T288	data 27018 27061	the midpoint method with an Euler predictor
R183	supports Arg1:T288 Arg2:T287	
R184	supports Arg1:T287 Arg2:T286	
T289	own_claim 27586 27631	we do not interpolate values stored on a grid
T290	data 27545 27584	evaluating φ at points near the surface
R185	supports Arg1:T290 Arg2:T289	
T291	own_claim 27642 27674	we compute exact distance values
R186	contradicts Arg1:T291 Arg2:T289	
R187	supports Arg1:T289 Arg2:T286	
T292	own_claim 27730 27789	of our method and do not affect the unconditional stability
T293	own_claim 27676 27715	These changes only improve the accuracy
R188	parts_of_same Arg1:T293 Arg2:T292	
T294	background_claim 27968 28039	detailed a method for computing the distance from a point to a triangle
T295	data 27939 27959	Schneider and Eberly
T296	data 27961 27965	2002
R189	parts_of_same Arg1:T295 Arg2:T296	
R190	supports Arg1:T296 Arg2:T294	
T297	background_claim 28085 28234	many triangles can be pruned, especially when x is very close to the surface, by using standard bounding-box techniques and our octree data structure
T298	background_claim 28041 28079	This operation is relatively expensive
T299	data 28240 28249	Section 6
R191	supports Arg1:T299 Arg2:T297	
T300	own_claim 28252 28333	Signing the distance values turns out to be somewhat difficult near sharp corners
T301	own_claim 29252 29297	the triangles do not always agree on the sign
T302	data 29149 29209	the nearest point in the mesh lies on more than one triangle
R192	supports Arg1:T302 Arg2:T301	
T303	data 29217 29249	on an edge or vertex of the mesh
R193	supports Arg1:T303 Arg2:T302	
T305	background_claim 29552 29616	provided a proof that this procedure results in accurate signing
T304	own_claim 29299 29523	These situations can be resolved by computing an angle-weighted pseudonormal for each edge and vertex of the mesh and using these pseudonormals to determine the sign when the nearest point is on an edge or vertex of the mesh
T306	data 29525 29544	Bærentzen and Aanæs
T307	data 29546 29550	2002
R194	parts_of_same Arg1:T307 Arg2:T306	
R195	supports Arg1:T306 Arg2:T305	
T308	own_claim 29640 29754	The ability to compute exact distances is one of the chief advantages of having an explicit surface representation
T309	own_claim 29756 29800	Interpolation can produce substantial errors
T310	own_claim 29817 29847	which are compounded over time
R196	parts_of_same Arg1:T309 Arg2:T310	
T311	data 29806 29814	Figure 3
R197	supports Arg1:T311 Arg2:T309	
T312	background_claim 29858 29950	this interpolation error is one of the most significant drawbacks to semi-Lagrangian methods
T313	background_claim 29997 30128	interpolation produces such significant smoothing that researchers have proposed a number of methods to add detail back to the flow
T314	background_claim 30150 30195	or avoid semi-Lagrangian advection altogether
T315	data 29968 29995	used for velocity advection
R198	parts_of_same Arg1:T313 Arg2:T314	
T316	data 30130 30148	Fedkiw et al. 2001
T317	data 30198 30218	Zhu and Bridson 2005
R199	supports Arg1:T317 Arg2:T314	
R200	supports Arg1:T316 Arg2:T313	
R201	supports Arg1:T315 Arg2:T313	
T318	own_claim 30235 30401	we are able to leverage the advantages of semi-Lagrangian advection, without incurring the interpolation error that would otherwise undesireably smooth surface detail
T319	own_claim 30463 30538	Our implementation makes heavy use of a structure we call the distance tree
T320	data 30540 30612	The distance tree is a balanced octree subdivision of the spatial domain
R202	supports Arg1:T320 Arg2:T319	
T321	own_claim 30762 30801	The distance tree serves three purposes
T322	own_claim 30807 30898	It provides a fast spatial index for the mesh so that nearby triangles can be found quickly
T323	own_claim 30904 31038	It provides a fast, approximate signed-distance function, which is sufficient when evaluating the signed distance far from the surface
T324	own_claim 31155 31172	contain triangles
R203	supports Arg1:T322 Arg2:T321	
R204	supports Arg1:T323 Arg2:T321	
T326	own_claim 31044 31143	It guides the contouring algorithm, quickly identifying cells which have vertices of different sign
R205	parts_of_same Arg1:T326 Arg2:T324	
R206	supports Arg1:T326 Arg2:T321	
T325	own_claim 32324 32362	the distance is guaranteed to be exact
T327	data 32267 32317	the computed distance is less than C’s edge length
R207	supports Arg1:T327 Arg2:T325	
T328	own_claim 32364 32472	Otherwise, the computed distance is a very good estimate but may be slightly larger than the actual distance
T329	own_claim 32629 32664	we do not require an exact distance
T330	own_claim 32599 32624	x is not near the surface
T331	data 32491 32533	C is not at the finest level of the octree
T332	data 32540 32592	there are no triangles in the concentric triple of C
T333	own_claim 32666 32718	An approximation with the correct sign is sufficient
R208	supports Arg1:T332 Arg2:T330	
R209	supports Arg1:T331 Arg2:T330	
R210	supports Arg1:T330 Arg2:T329	
T334	own_claim 33078 33151	it is also useful to build a distance tree from an existing triangle mesh
T335	own_claim 32975 33067	Most often, we wish to build a distance tree to resolve the zero set of our field function ψ
T336	own_claim 33153 33288	Our octrees are always built in a top-down manner where each cell is split based on some variation of the following splitting criterion
T337	data 33328 33404	Split any cell whose edge length exceeds its minimum distance to the surface
R211	supports Arg1:T337 Arg2:T336	
T338	data 33313 33315	11
R212	parts_of_same Arg1:T338 Arg2:T337	
T339	background_claim 33510 33541	results in a three-color octree
T340	background_claim 33506 33508	11
R213	parts_of_same Arg1:T340 Arg2:T339	
T341	background_claim 33574 33660	where each cell of the octree has one of three types: interior, exterior, and boundary
R214	parts_of_same Arg1:T339 Arg2:T341	
T342	data 33559 33564	Samet
T343	data 33566 33570	1990
R215	parts_of_same Arg1:T343 Arg2:T342	
R216	supports Arg1:T342 Arg2:T339	
T344	data 33666 33674	Figure 4
R217	supports Arg1:T344 Arg2:T341	
T345	background_claim 33690 33699	Criterion
T346	background_claim 33705 33750	builds octrees with several useful properties
T347	background_claim 33701 33703	11
R218	parts_of_same Arg1:T345 Arg2:T347	
R219	parts_of_same Arg1:T347 Arg2:T346	
T348	background_claim 33753 33812	Adjacent cells differ in size by no more than a factor of 2
T349	background_claim 33495 33504	Criterion
R220	parts_of_same Arg1:T349 Arg2:T340	
T350	background_claim 33814 33864	producing a smooth mesh and simplifying procedures
T351	data 33873 33889	neighbor finding
T352	data 33894 33923	triangulation of the vertices
T353	background_claim 33926 33986	A cell’s size is proportional to its distance to the surface
T354	background_claim 34137 34160	φ will be discontinuous
R221	supports Arg1:T348 Arg2:T350	
R222	supports Arg1:T350 Arg2:T346	
R223	supports Arg1:T351 Arg2:T350	
R224	supports Arg1:T352 Arg2:T350	
R225	supports Arg1:T353 Arg2:T346	
T355	data 33992 34043	φ is the signed distance to the surface at vertices
T356	data 34048 34101	we extend φ into each cell by trilinear interpolation
T357	data 34117 34135	cells vary in size
T358	background_claim 34171 34228	the jumps in φ decrease in size in cells near the surface
R226	supports Arg1:T355 Arg2:T354	
T359	data 34240 34263	the triangle inequality
T360	background_claim 34270 34326	the interpolated φ is nearly continuous near the surface
R227	contradicts Arg1:T358 Arg2:T354	
R228	supports Arg1:T356 Arg2:T354	
R229	supports Arg1:T357 Arg2:T354	
R230	supports Arg1:T359 Arg2:T358	
R231	supports Arg1:T358 Arg2:T360	
R232	supports Arg1:T360 Arg2:T346	
T361	data 34382 34430	there are N childless cells touching the surface
T362	background_claim 34437 34484	the entire tree contains only O(N log N ) cells
T363	background_claim 34329 34377	Cells coarsen very rapidly away from the surface
R233	supports Arg1:T362 Arg2:T363	
R234	supports Arg1:T361 Arg2:T362	
T364	background_claim 34492 34542	the surface is resolved accurately at minimal cost
R235	supports Arg1:T363 Arg2:T364	
R236	supports Arg1:T364 Arg2:T346	
T365	own_claim 34961 35015	we are essentially trying to resolve our approximation
T366	own_claim 35054 35097	ψ n+1 (x) = φ n (x − ( t)v(x n−1/2 , t n ))
T367	own_claim 35039 35041	12
T368	own_claim 35119 35160	to the signed-distance function φ n+1 (x)
R237	parts_of_same Arg1:T365 Arg2:T367	
R238	parts_of_same Arg1:T367 Arg2:T366	
R239	parts_of_same Arg1:T366 Arg2:T368	
T369	data 34904 34959	building a new octree at the beginning of each timestep
R240	supports Arg1:T369 Arg2:T365	
T370	background_claim 37355 37445	is an instance of the contouring problem, which has been well studied in computer graphics
T371	background_claim 37273 37310	Creating this explicit representation
R241	parts_of_same Arg1:T371 Arg2:T370	
T372	own_claim 37554 37584	Our implementation is based on
T373	data 37585 37598	Bloomenthal’s
T374	data 37600 37604	1994
R242	parts_of_same Arg1:T374 Arg2:T373	
R243	supports Arg1:T373 Arg2:T372	
T375	own_claim 38356 38412	The marching-cubes algorithm works well for our purposes
T376	data 38421 38518	each triangle generated by marching cubes sits strictly inside a single cell of the distance tree
T377	own_claim 38520 38582	making the distance tree an especially effective spatial index
R245	supports Arg1:T376 Arg2:T377	
R244	supports Arg1:T377 Arg2:T375	
T378	own_claim 38175 38288	each vertex in our polygon mesh can be mapped to some point on some triangle in the mesh at the previous timestep
T379	own_claim 38597 38760	we use the distance tree we have already built to guide the marching cubes, avoiding the need to build a second structure to determine the topology of the new mesh
R246	supports Arg1:T379 Arg2:T375	
T380	own_claim 38875 38935	we need not worry about patching the marching-cubes solution
T381	own_claim 38937 39003	Our choice of contouring algorithm does result in some limitations
T382	own_claim 39005 39083	In addition to creating poorly shaped triangles, marching cubes is nonadaptive
T383	data 39094 39166	the sampling is as dense in flat regions as in regions of high curvature
R247	supports Arg1:T383 Arg2:T382	
T384	own_claim 39183 39326	the nonadaptive nature of marching cubes limits the resolution we can achieve in high-curvature areas, but is necessary to ensure compatibility
T385	background_claim 39328 39386	To address this lack of resolution in high-curvature areas
T386	background_claim 39403 39498	split line segments whose centers were far from the surface, yielding arbitrarily high accuracy
R248	parts_of_same Arg1:T385 Arg2:T386	
T387	data 39388 39394	Strain
T388	data 39396 39400	2001
R249	parts_of_same Arg1:T388 Arg2:T387	
R250	supports Arg1:T387 Arg2:T385	
T389	own_claim 39515 39582	this splitting technique is not easily extended to three dimensions
T390	data 39586 39697	splitting a triangle either creates an incompatible triangulation or produces even more poorly shaped triangles
R251	supports Arg1:T390 Arg2:T389	
T391	own_claim 39699 39824	It is also very difficult to guarantee that we will still have a manifold when the inserted vertices are moved to the surface
T392	background_claim 39841 39876	several adaptive contouring methods
T393	background_claim 39938 40031	seek to use adaptive grids and regain compatibility through various crack-patching techniques
R252	parts_of_same Arg1:T392 Arg2:T393	
T394	data 39879 39894	Shu et al. 1995
T395	data 39896 39915	Shekhar et al. 1996
T396	data 39917 39935	Poston et al. 1998
R253	supports Arg1:T394 Arg2:T392	
R254	supports Arg1:T395 Arg2:T392	
R255	supports Arg1:T396 Arg2:T392	
T397	own_claim 40033 40071	Such methods could easily be used here
T398	own_claim 40076 40126	we plan to explore adaptive methods in future work
T400	background_claim 40905 40994	This function is quite similar to the functions used in semi-Lagrangian level-set methods
T401	data 40996 41008	Strain 1999b
T402	data 41010 41029	Enright et al. 2005
R256	supports Arg1:T401 Arg2:T400	
R257	supports Arg1:T402 Arg2:T400	
T403	own_claim 41383 41448	this smoothing technique may be quite useful in some applications
T404	own_claim 41450 41515	we did not use this method for any of the results in this article
R258	contradicts Arg1:T404 Arg2:T403	
T399	own_claim 42114 42148	this limitation is not significant
T405	own_claim 42013 42065	This jittering limits the reusability of our octrees
R259	contradicts Arg1:T399 Arg2:T405	
T406	data 42077 42112	we build new octrees every timestep
R260	supports Arg1:T406 Arg2:T399	
T407	background_claim 42595 42607	This problem
T408	background_claim 42638 42730	has been well studied by the level-set community and a number of methods have been suggested
R261	parts_of_same Arg1:T407 Arg2:T408	
T409	data 42624 42636	redistancing
R262	supports Arg1:T409 Arg2:T407	
T410	background_claim 42748 42834	suggested redistancing by performing an exact evaluation at every vertex of the octree
T411	background_claim 42836 42871	This method is relatively efficient
T412	data 42732 42738	Strain
T413	data 42740 42745	1999a
R263	parts_of_same Arg1:T412 Arg2:T413	
R264	supports Arg1:T413 Arg2:T410	
T414	data 42878 42958	the tree coarsens rapidly away from the surface and works well in two dimensions
R265	supports Arg1:T414 Arg2:T411	
T415	own_claim 42969 43052	in three dimensions, we have found it to be prohibitively expensive and unnecessary
R266	supports Arg1:T415 Arg2:T411	
T416	own_claim 43453 43463	our octree
T417	own_claim 43510 43560	does not necessarily coarsen away from the surface
R267	parts_of_same Arg1:T416 Arg2:T417	
T418	own_claim 43562 43668	To address this problem, we coarsen parts of the tree which have been refined but did not generate surface
T419	own_claim 43956 44001	Our redistancing method comprises three steps
T420	data 44004 44022	coarsen the octree
R268	supports Arg1:T420 Arg2:T419	
T421	data 44025 44093	compute exact distances at vertices of cells which contain triangles
T422	data 44096 44150	run a fast marching method over the remaining vertices
R269	supports Arg1:T421 Arg2:T419	
R270	supports Arg1:T422 Arg2:T419	
T423	own_claim 44222 44308	One of the primary advantages of our method is the ability to track surface properties
T424	own_claim 44376 44416	accurately at negligible additional cost
R271	parts_of_same Arg1:T423 Arg2:T424	
T425	data 44318 44323	color
T426	data 44325 44344	texture coordinates
T427	data 44354 44374	simulation variables
R272	supports Arg1:T425 Arg2:T423	
R273	supports Arg1:T426 Arg2:T423	
R274	supports Arg1:T427 Arg2:T423	
T428	own_claim 44544 44627	semi-Lagrangian advection provides a mapping between surfaces at adjacent timesteps
T429	own_claim 44442 44536	every vertex in a polygon mesh corresponds to some point on some triangle in the previous mesh
R275	supports Arg1:T429 Arg2:T428	
T430	own_claim 44736 44768	this property can be copied to v
T431	data 44632 44692	vertex v in the current mesh maps to point p in the old mesh
T432	data 44697 44734	some surface property was stored at p
R276	supports Arg1:T432 Arg2:T430	
T433	own_claim 44782 44859	we can track surface properties on the actual surface as we build the surface
R277	supports Arg1:T431 Arg2:T430	
T434	own_claim 44864 44911	we do not incur any significant additional cost
R278	supports Arg1:T433 Arg2:T434	
T435	background_claim 44913 44929	Previous methods
T436	background_claim 44987 45096	have been limited to tracking properties in the volume near the surface and interpolating them to the surface
R279	parts_of_same Arg1:T435 Arg2:T436	
T437	data 44960 44977	Rassmussen et al.
T438	data 44979 44983	2004
R280	parts_of_same Arg1:T437 Arg2:T438	
R281	supports Arg1:T437 Arg2:T435	
T439	background_claim 45098 45211	Such methods incur significant cost, introduce substantial smoothing, and blur properties between nearby surfaces
T440	own_claim 45783 45860	we are having trouble because we are resampling the surface at every timestep
T441	own_claim 45723 45768	this approach may introduce unwanted aliasing
T442	own_claim 45213 45272	In many applications there is no value actually stored at p
T443	own_claim 45283 45353	the properties are stored at the vertices of the triangle containing p
T444	own_claim 45355 45407	In these cases the problem is slightly more involved
T445	own_claim 45409 45534	In many cases it is sufficient to use barycentric interpolation to compute a value at p and copy this interpolated value to v
T446	own_claim 45545 45616	for some applications this interpolation can produce unwanted smoothing
R282	contradicts Arg1:T446 Arg2:T445	
T447	own_claim 45618 45706	A simple alternative is to set the value at pto the value stored at the vertex nearest p
T448	own_claim 45928 45975	we may be able to “clean up” the blurred signal
T449	data 45874 45926	we know something about the property we are tracking
R283	supports Arg1:T449 Arg2:T448	
T450	own_claim 46667 46735	texture coordinates could be copied instead of reference coordinates
T451	data 46611 46665	image textures were preferred over procedural textures
T452	own_claim 46737 46817	There are still plenty of open problems in the area of texturing liquid surfaces
T453	own_claim 46834 46964	it is difficult to deal with large discontinuities in surface properties, which occur when two surfaces merge, or a surface splits
T454	own_claim 46966 47031	Creating detail where a surface stretches is also an open problem
T455	own_claim 50169 50277	All of our fluid examples used a standard regular-grid Eulerian fluid simulator with the elasticity model of
T456	data 50279 50294	Goktekin et al.
T457	data 50296 50300	2004
R284	parts_of_same Arg1:T456 Arg2:T457	
R285	supports Arg1:T456 Arg2:T455	
T458	own_claim 50600 50680	its resolution is notably coarser than the surface tracker, which uses an octree
T459	data 50561 50599	our fluid simulator has a regular grid
R286	supports Arg1:T459 Arg2:T458	
T460	background_claim 50683 50759	The idea of using different resolutions for the fluid and surface is not new
T461	background_claim 50787 50852	used different timesteps for their fluid and surface calculations
T462	data 50762 50779	Foster and Fedkiw
T463	data 50781 50785	2001
R287	parts_of_same Arg1:T463 Arg2:T462	
T464	background_claim 50893 50988	increasing the spatial resolution of the surface tracking grid dramatically reduced volume loss
R288	supports Arg1:T463 Arg2:T461	
T465	data 50858 50873	Goktekin et al.
T466	data 50875 50879	2004
R289	parts_of_same Arg1:T465 Arg2:T466	
R290	supports Arg1:T466 Arg2:T464	
T467	background_claim 51026 51083	using different spatial resolutions can produce artifacts
T468	data 51002 51016	Losasso et al.
T469	data 51018 51022	2004
R291	parts_of_same Arg1:T468 Arg2:T469	
R292	supports Arg1:T469 Arg2:T467	
T470	data 51098 51201	pieces of surface could appear connected when the simulator thinks they are disconnected and vice versa
R293	supports Arg1:T470 Arg2:T467	
T471	data 51217 51311	surface features may be maintained when a more detailed fluid simulator would smooth them away
R294	supports Arg1:T471 Arg2:T467	
T472	own_claim 51325 51394	we found the increased surface resolution to be worth these artifacts
T473	own_claim 51396 51478	Ideally we would use a multiresolution fluid simulation, like the octree method of
T474	data 51479 51493	Losasso et al.
T475	data 51495 51499	2004
R295	parts_of_same Arg1:T474 Arg2:T475	
R296	supports Arg1:T474 Arg2:T473	
T476	own_claim 51502 51585	We plan to incorporate a multiresolution fluid simulator as part of our future work
T477	own_claim 52040 52134	given a perfect semi-Lagrangian path tracer, the method could take arbitrarily large timesteps
T479	own_claim 52136 52296	Decoupling the timesteps of the fluid simulator and surface tracker, so that the surface tracker runs only once per frame, is an interesting area of future work
T478	own_claim 53156 53205	Similar effects can be seen in real-world footage
T480	own_claim 53207 53274	All of our images were rendered with the open-source renderer Pixie
T481	data 53277 53288	Arikan 2005
R297	supports Arg1:T481 Arg2:T480	
T482	data 53297 53341	we generated a polygonal mesh for each frame
T483	own_claim 53343 53399	we could take advantage of standard rendering techniques
R298	supports Arg1:T482 Arg2:T483	
T484	own_claim 54491 54529	allowing for very fast rendering times
R299	parts_of_same Arg1:T483 Arg2:T484	
T485	data 54531 54580	most of our renderings took less than 3 min/frame
R300	supports Arg1:T485 Arg2:T484	
T486	own_claim 54852 54904	the method can be used to generate realistic results
T487	data 54677 54740	A number of our examples were also rendered with a glass shader
R301	supports Arg1:T487 Arg2:T486	
T488	own_claim 54955 55016	easily a variety of properties may be attached to the surface
T489	own_claim 55018 55173	In practice, we believe that advected properties could be used effectively with standard shading techniques to generate a wide range of interesting effects
T490	data 54906 54939	Our colored and textured examples
R302	supports Arg1:T490 Arg2:T488	
T491	own_claim 55230 55315	Semi-Lagrangian contouring offers an elegant and effective means for surface tracking
T492	own_claim 55320 55369	has a number of advantages over competing methods
T493	own_claim 55378 55412	we have an explicit representation
T494	own_claim 55414 55598	In addition to enabling exact evaluation, this explicit representation also allows us to leverage 30 years of computer graphics technology which has been optimized for polygonal meshes
R303	supports Arg1:T493 Arg2:T492	
T495	own_claim 55600 55692	Rendering, texture mapping, and a variety of other applications are all very straightforward
T496	own_claim 55702 55736	we have an implicit representation
T497	own_claim 55738 55898	This implicit representation allows us to update the surface without explicitly addressing any of the difficult topological issues which plague other approaches
R304	supports Arg1:T496 Arg2:T492	
T498	own_claim 55907 55990	semi-Lagrangian advection gives us a mapping between surfaces at adjacent timesteps
R305	supports Arg1:T498 Arg2:T492	
T499	own_claim 55992 56109	This mapping allows us to accurately track surface properties on the actual surface at negligible complexity and cost
T500	own_claim 56119 56182	our method does not have any ad hoc rules or parameters to tune
R306	supports Arg1:T500 Arg2:T492	
T501	own_claim 56377 56476	most importantly, we are able to produce detailed, flicker-free animations of complex fluid motions
R307	supports Arg1:T501 Arg2:T492	
T502	data 56193 56305	the only parameters to our system are the upper and lower corners of the domain, the maximum depth of the octree
T503	data 56332 56362	and some resolution tolerances
R308	parts_of_same Arg1:T502 Arg2:T503	
R309	supports Arg1:T502 Arg2:T500	
