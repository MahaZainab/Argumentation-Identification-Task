T1	background_claim 2452 2582	Skinning is an important part of realistic articulated body animation and is an important topic of computer graphics and animation
T2	background_claim 2595 2684	skinning can be categorized into algorithmic, physically-based, and example-based methods
T3	background_claim 2708 2811	simple algorithmic skinning schemes cannot capture the complexity and subtlety of real skin deformation
T4	background_claim 2695 2706	widely used
R1	contradicts Arg1:T3 Arg2:T4	
T5	background_claim 2817 2892	revised approaches will be required to increase character animation realism
R2	supports Arg1:T3 Arg2:T5	
T6	background_claim 2894 3016	Physically-based skinning is based on the biomechanics of skin deformation arising from the motions of muscles and tendons
T7	background_claim 3027 3099	this approach can generate physically accurate simulations of each layer
T8	background_claim 3101 3157	it is not at present suitable for real time applications
T9	background_claim 3180 3210	the large computation required
R3	supports Arg1:T9 Arg2:T8	
R4	contradicts Arg1:T8 Arg2:T7	
T10	background_claim 3212 3378	Example-based methods capture some of the complexity of real skin deformation by interpolating scanned or sculpted examples of the desired skin shape in various poses
T11	background_claim 3397 3476	this requires gathering a sufficient number of samples and some pre-calculation
T12	background_claim 3478 3549	example-based methods can potentially be used in real-time applications
T13	background_claim 3557 3602	their relatively simple real-time computation
R5	supports Arg1:T13 Arg2:T12	
R6	contradicts Arg1:T12 Arg2:T11	
T14	background_claim 3604 3635	Weighted pose space deformation
T15	background_claim 3643 3753	is an example based skinning method that generates high quality skinning with a limited number of sample poses
R7	parts_of_same Arg1:T15 Arg2:T14	
T16	data 3756 3760	KM04
R8	supports Arg1:T16 Arg2:T15	
T17	background_claim 3773 3809	it can generate an accurate skinning
T18	background_claim 3811 3880	it requires more computation than the original pose space deformation
R9	contradicts Arg1:T18 Arg2:T17	
T19	data 3889 3894	LCF00
R10	supports Arg1:T19 Arg2:T18	
T20	background_claim 3903 3961	joint distances are computed independently for each vertex
R11	supports Arg1:T20 Arg2:T18	
T21	background_claim 3972 4032	this method has not been suitable for real-time applications
R12	supports Arg1:T18 Arg2:T21	
T22	background_claim 4047 4102	both WPSD and SSD require joint weights for each vertex
T23	background_claim 4108 4167	accurate joint weights are required to achieve good results
T24	background_claim 4178 4231	the weights are usually manually generated by artists
T25	background_claim 4239 4270	requires effort and great skill
T26	data 4286 4311	a complex skeletal system
R13	supports Arg1:T26 Arg2:T25	
R14	supports Arg1:T24 Arg2:T25	
T27	own_claim 4351 4387	we present a parallel WPSD algorithm
T28	own_claim 4441 4472	suitable for SIMD architectures
R15	parts_of_same Arg1:T28 Arg2:T27	
T29	own_claim 4495 4504;4505 4580	The joint 	  weights for each vertex are automatically computed from the sample poses
T30	own_claim 4582 4649	This can enhance the skinning quality not only of SSD but also WPSD
T31	background_claim 4657 4706	both methods require accurate joint weight values
R16	supports Arg1:T31 Arg2:T30	
T32	background_claim 4708 4779	The deformation required in WPSD and SSD is independent for each vertex
T33	background_claim 4784 4854	this per-vertex computation can be parallelized in a SIMD architecture
T34	own_claim 5053 5136	we can speed up SSD, PSD, as well as WPSD to around 20 times faster than on the CPU
T35	data 5138 5238	from 1.2FPS to 25FPS speed-up of WPSD on a detailed model having 22836 triangles with 11574 vertices
R17	supports Arg1:T35 Arg2:T34	
T36	own_claim 5240 5268	using a modern graphics card
R18	parts_of_same Arg1:T36 Arg2:T34	
T37	own_claim 5275 5350	making WPSD a feasible real-time skinning solution for various applications
R19	supports Arg1:T36 Arg2:T37	
T38	data 5361 5366	games
T39	data 5368 5383	virtual reality
R20	supports Arg1:T38 Arg2:T37	
R21	supports Arg1:T39 Arg2:T37	
T40	data 5389 5416	other real-time simulations
R22	supports Arg1:T40 Arg2:T37	
T41	background_claim 5466 5650	Many commercial software packages generate skin deformation arising from joint movement using a method known as (linear blend) skinning, Skeletal Subspace Deformation (SSD), enveloping
T42	background_claim 5658 5707	based in part on work published by Thalmann et al
T43	data 5710 5716	MTLT88
R23	supports Arg1:T43 Arg2:T42	
T44	background_claim 5719 5796	SSD is based on the weighted blending of affine transformations of each joint
T45	background_claim 5801 5836	used in many real-time applications
T46	background_claim 5844 5875	its simple and fast computation
R24	supports Arg1:T46 Arg2:T45	
T47	background_claim 5886 5928	it also exhibits some well known artifacts
R25	contradicts Arg1:T47 Arg2:T45	
T48	data 5937 6000	skin that collapses around the joints at increasing bend angles
R26	supports Arg1:T48 Arg2:T47	
T49	background_claim 6006 6067	a variety of solutions for these problems have been published
T50	data 6070 6075	Web00
R27	supports Arg1:T50 Arg2:T49	
T51	data 6077 6081	WP02
R28	supports Arg1:T51 Arg2:T49	
T52	data 6083 6088	MTG03
R29	supports Arg1:T52 Arg2:T49	
T53	data 6090 6094	KZ05
R30	supports Arg1:T53 Arg2:T49	
T54	background_claim 6097 6128	Recently, example-based methods
T55	background_claim 6165 6209	have permitted more complex skinning effects
T56	data 6130 6135	LCF00
T57	data 6137 6142	SRC01
T58	data 6144 6149	ACP02
T59	data 6151 6156	KJP02
T60	data 6158 6162	KM04
R31	supports Arg1:T56 Arg2:T54	
R32	supports Arg1:T57 Arg2:T54	
R33	supports Arg1:T58 Arg2:T54	
R34	supports Arg1:T59 Arg2:T54	
R35	supports Arg1:T60 Arg2:T54	
R36	parts_of_same Arg1:T55 Arg2:T54	
T61	data 6218 6231	muscle bulges
R37	supports Arg1:T61 Arg2:T55	
T62	data 6236 6250	major wrinkles
R38	supports Arg1:T62 Arg2:T55	
T63	background_claim 6252 6317	while also addressing the artifacts of simple algorithmic schemes
R39	parts_of_same Arg1:T63 Arg2:T55	
T64	background_claim 6741 6821	the amount of memory for these methods grows with the number of training samples
T65	background_claim 6827 6870	arbitrary distributions can be approximated
T66	background_claim 6872 7003	Some of the most impressive example-based results to date are those of Kurihara and Miyata’s hand model derived from medical images
T67	data 7006 7010	KM04
R40	supports Arg1:T67 Arg2:T66	
T68	background_claim 7019 7070	acquiring 3D medical images is relatively expensive
T69	background_claim 7072 7118	they developed weighted pose space deformation
T70	background_claim 7126 7191	to generate proper skinning from a limited number of pose samples
R41	parts_of_same Arg1:T70 Arg2:T69	
R42	supports Arg1:T68 Arg2:T69	
T71	background_claim 7193 7330	They modify the distance between poses using the joint weights of each vertex to provide a more appropriate distance measure for skinning
R43	supports Arg1:T67 Arg2:T69	
R44	supports Arg1:T67 Arg2:T71	
T72	background_claim 7341 7423	the joint weights for each vertex are important data for SSD and WPSD calculations
T73	background_claim 7425 7491	they have traditionally been manually generated by skilled artists
R45	contradicts Arg1:T73 Arg2:T72	
T74	background_claim 7493 7571	Least-squares based vertex weight estimation was shown in the skinning methods
T75	data 7574 7578	WP02
T76	data 7580 7585	MTG03
R46	supports Arg1:T75 Arg2:T74	
R47	supports Arg1:T76 Arg2:T74	
T77	background_claim 7588 7702	James et al. describe mesh based skinning including estimation of bone parameters and vertex weights for each bone
T78	data 7705 7709	JT05
R48	supports Arg1:T78 Arg2:T77	
T79	background_claim 7712 7783	In their paper, the vertex weights of each joint are calculated by NNLS
R49	supports Arg1:T78 Arg2:T79	
T80	own_claim 7817 7883	we derive a similar approach to calculate weights for SSD and WPSD
T81	background_claim 7908 7981	the performance of GPUs has been improving more rapidly than that of CPUs
T82	background_claim 7987 8058	GPUs have many processing units serving as a SIMD parallel architecture
T83	background_claim 8060 8116	many algorithms have been accelerated by GPU programming
R50	supports Arg1:T82 Arg2:T83	
R51	supports Arg1:T81 Arg2:T83	
T84	data 8118 8126	LHK ∗ 04
R52	supports Arg1:T84 Arg2:T83	
T85	data 8128 8132	PF05
R53	supports Arg1:T85 Arg2:T83	
T86	data 8134 8137	GPG
R54	supports Arg1:T86 Arg2:T83	
T87	background_claim 8140 8204	Deformation and skinning algorithms can also be enhanced by GPUs
T88	data 8250 8254	JP02
R55	supports Arg1:T88 Arg2:T87	
T89	data 8256 8261	KJP02
R56	supports Arg1:T89 Arg2:T87	
T90	data 8263 8267	BK05
R57	supports Arg1:T90 Arg2:T87	
T91	data 8269 8273	JT05
R58	supports Arg1:T91 Arg2:T87	
T92	background_claim 8313 8374	vertex information cannot be accessed in the fragment program
T93	background_claim 8376 8444	GPU-based vertex deformation is usually performed by vertex programs
T94	background_claim 8285 8305	in previous research
R59	supports Arg1:T92 Arg2:T93	
R60	parts_of_same Arg1:T93 Arg2:T94	
R61	contradicts Arg1:T93 Arg2:T87	
T95	own_claim 8461 8568	we develop a parallel WPSD method using the fragment processors to gain greater parallelism and performance
T96	background_claim 8570 8689	Person-specific data modeling and its deformation is also an interesting topic in realistic articulated body simulation
T97	background_claim 8691 8767	Rhee et al. described human hand modeling from surface anatomy of the person
T98	data 8770 8775	RNL06
R62	supports Arg1:T98 Arg2:T97	
T99	background_claim 8778 8939	Anguelov et al. developed shape completion and animation of people, derived from the set of range scan data and example based deformation in pose and shape space
T100	data 8941 8949	ASK ∗ 05
R63	supports Arg1:T100 Arg2:T99	
T101	background_claim 8952 9062	Physically inspired skinning should be also recognized as another important area of articulated body animation
T102	data 9140 9145	AHS03
R64	supports Arg1:T102 Arg2:T101	
T103	data 9147 9155	CBC ∗ 05
T104	data 9157 9163	PCLS05
T105	data 9165 9170	SNF05
R65	supports Arg1:T103 Arg2:T101	
R66	supports Arg1:T104 Arg2:T101	
R67	supports Arg1:T105 Arg2:T101	
T106	background_claim 9232 9314	Example-based skinning problems can be described by the following general equation
T107	background_claim 9347 9373	v(p a ) = S(v 0 + D(p a ))
R68	parts_of_same Arg1:T107 Arg2:T106	
T108	background_claim 9626 9777	In skeletal subspace deformation the displacement D(p a ) is omitted and the target surface is calculated by SSD as a blend of affine transforms of v 0
T109	data 9779 9790	section 3.1
R69	supports Arg1:T109 Arg2:T108	
T110	background_claim 9793 9917	Skinning methods related to PSD use the displacement of an arbitrary pose D(p a ), calculated by interpolation in pose space
T111	data 9919 9930	section 3.2
R70	supports Arg1:T111 Arg2:T110	
T112	background_claim 10602 10605	SSD
T113	data 10607 10613	MTLT88
T114	background_claim 10615 10702	is based on the weighted blending of an affine transformation of each joint by equation
R71	supports Arg1:T113 Arg2:T112	
R72	parts_of_same Arg1:T114 Arg2:T112	
T115	background_claim 10737 10781	n joint v a = S(v 0 ) = ( ∑ w j T j )v 0 j=1
R73	parts_of_same Arg1:T115 Arg2:T114	
T116	background_claim 11095 11129	usually ∑ n j=1 joint (w j ) = 1.0
T117	background_claim 11023 11090	The weight w j can be assigned by the artist to control deformation
T118	background_claim 11131 11234	This simple algorithm is used in many commercial graphics packages and real-time rendering applications
T119	background_claim 11239 11264	shows several limitations
R74	contradicts Arg1:T119 Arg2:T118	
T120	background_claim 11274 11377	the deformation of this method is restricted to the subspace of the affine transformation of the joints
R75	supports Arg1:T120 Arg2:T119	
T121	data 11380 11385	LCF00
R76	supports Arg1:T121 Arg2:T120	
T122	data 11464 11550	we have a sufficient set of examples to describe the movement of an articulated object
T123	background_claim 11552 11599	we can interpolate displacement in “pose space”
R77	supports Arg1:T122 Arg2:T123	
T124	data 11601 11606	LCF00
R78	supports Arg1:T124 Arg2:T123	
T125	data 11756 11838	we translate each skinning sample k to the rest coordinate frame using inverse SSD
T126	background_claim 11840 11868	the displacement between the
T127	background_claim 11901 11970	sample vertex v k and the rest pose vertex can be calculated: n joint
T128	background_claim 12002 12038	d k = ( ∑ w j T j ) −1 v k − v 0 j=1
R79	supports Arg1:T125 Arg2:T126	
R80	parts_of_same Arg1:T127 Arg2:T126	
R81	parts_of_same Arg1:T128 Arg2:T127	
T129	background_claim 12304 12412	After defining the displacement of each pose, the displacement at an arbitrary pose can be calculated by RBF
T130	data 12439 12444	LCF00
T131	background_claim 12446 12481	or normalized radial basis function
R82	supports Arg1:T130 Arg2:T129	
R83	parts_of_same Arg1:T131 Arg2:T129	
T132	data 12484 12488	KM04
R84	supports Arg1:T132 Arg2:T131	
T133	background_claim 12490 12539	interpolation of the example poses’ displacements
R85	parts_of_same Arg1:T133 Arg2:T131	
T134	background_claim 12541 12626	The displacement d a of a vertex in an arbitrary pose p a can be calculated as n pose
T135	background_claim 12658 12693	d a = D(p a ) = ∑ r k (p a )d k k=1
R86	parts_of_same Arg1:T135 Arg2:T134	
T136	background_claim 12890 12973	Normalized Radial Basis Functions can smoothly interpolate pose space using: n pose
T137	background_claim 13005 13040	f t (p a ) = ∑ λ t,k φ k (γ k ) k=1
R87	parts_of_same Arg1:T137 Arg2:T136	
T138	background_claim 13436 13590	The weight r k (p a ) is calculated using normalized RBFs and is used in equation 4 to calculate the displacement d a of a vertex in an arbitrary pose p a
T139	background_claim 13748 13787	r k (p a ) = ∑ n pose f k (p f a (p ) )
R88	parts_of_same Arg1:T139 Arg2:T138	
T140	background_claim 14053 14089	WPSD is developed by Kurihara et al.
T141	data 14092 14096	KM04
R89	supports Arg1:T141 Arg2:T140	
T142	background_claim 14098 14172	to deform their example-based human hand model derived from medical images
R90	parts_of_same Arg1:T142 Arg2:T140	
T143	data 14421 14500	the γ k is the difference of n joint dimensional joint vectors of related poses
T144	background_claim 14502 14624	every vertex in the pose p k has same distance γ k resulting in the same weight r k (p a ) in every vertex of the pose p k
R91	supports Arg1:T143 Arg2:T144	
T145	background_claim 14174 14305	In the original PSD, the distance between two poses p a and p k having n joint number of joints for each pose is defined as n joint
T146	background_claim 14337 14382	γ k (p a , p k ) = ∑ (p a, j − p k, j ) 2 j=1
R92	parts_of_same Arg1:T146 Arg2:T145	
T147	background_claim 14648 14728	each element of the joint vector equally contributes to the distance calculation
T148	background_claim 14730 14809	two vectors having a same value but different order generate same pose distance
R93	supports Arg1:T147 Arg2:T148	
T149	background_claim 14824 14978	three different joint vectors p 1 = (θ, 0, 0), p 2 = (0, θ, 0), p 3 = (0, 0, θ) have same distance between them and it can cause unexpected results in PSD
R94	supports Arg1:T149 Arg2:T148	
T150	background_claim 14980 14987	In WPSD
T151	data 14989 14993	KM04
R95	supports Arg1:T151 Arg2:T150	
T152	background_claim 14996 15148	Kurihara et al. modify the distance definition between poses using joint weight of each vertex i to give proper weight to each element of a joint vector
T153	background_claim 15181 15243	n joint γ i,k (p a , p k ) = ∑ w i, j (p a, j − p k, j ) 2 j=1
R96	parts_of_same Arg1:T153 Arg2:T152	
R97	parts_of_same Arg1:T152 Arg2:T150	
T154	background_claim 15404 15467	From this definition, a more accurate pose distance is obtained
T155	background_claim 15472 15519	it generates better skinning in arbitrary poses
T156	background_claim 15829 15912	The joint weights of each vertex are important to generate accurate skinning in SSD
T157	data 15914 15924	equation 2
R98	supports Arg1:T157 Arg2:T156	
T158	background_claim 15926 15944	as well as in WPSD
R99	parts_of_same Arg1:T158 Arg2:T156	
T159	data 15946 15956	equation 8
R100	supports Arg1:T159 Arg2:T158	
T160	background_claim 15959 16034	In many applications, the weights are manually generated by skilled artists
T161	background_claim 16039 16077	it is hard to generate accurate values
T162	data 16083 16136	a number of joints are involved in deforming a region
R101	supports Arg1:T162 Arg2:T161	
T163	own_claim 16153 16278	we automatically calculate the joint weights of each vertex from the sample poses to enhance the accuracy of the weight value
T164	own_claim 16280 16380	This results in better skinning and reduces the elaborate manual work required to create weight maps
T165	own_claim 16382 16456	In each sample pose p k , we have following equation based on SSD: n joint
T166	own_claim 16488 16523	v  ̃ k − e k = ( ∑ w j T j )v 0 j=1
R102	parts_of_same Arg1:T166 Arg2:T165	
T167	data 16786 16854	we have sufficient examples involving the same set of n joint joints
T168	own_claim 16856 16901	we have n pose equations of the form: n joint
T169	own_claim 16934 16966	v  ̃ k − e k = ( ∑ v j w j ) j=1
R103	parts_of_same Arg1:T169 Arg2:T168	
R104	supports Arg1:T167 Arg2:T168	
T170	own_claim 17031 17049	the e k is unknown
T171	own_claim 17051 17198	we can solve for weights that minimize the e k in a least squares sense by stacking the equations 10 (with e k omitted) into a linear matrix system
T172	own_claim 17231 17239	2 v − Aw
R105	parts_of_same Arg1:T172 Arg2:T171	
R106	contradicts Arg1:T171 Arg2:T170	
T173	own_claim 17429 17534	From equation 11, we can calculate w from the given value of v and A to reduce the error of this equation
T174	own_claim 17536 17608	We use the non-negative least square (NNLS) method to solve this problem
T175	own_claim 17613 17681	it determines positive weight values minimizing error in equation 10
T176	own_claim 17683 17762	The calculated weight vector w is normalized to satisfy ∑ n j=1 joint w j = 1.0
T177	own_claim 17764 17878	In order to avoid a singular matrix A, the number of poses should be greater or equal to the number of overall DOF
T178	own_claim 17899 17918	of the joint vector
R107	parts_of_same Arg1:T178 Arg2:T177	
T179	own_claim 17947 17996	the sample poses should be sufficiently different
T180	background_claim 17998 18075	James et al. used a similar approach to estimate vertex weights in each joint
T181	data 18077 18081	JT05
R108	supports Arg1:T181 Arg2:T180	
T182	background_claim 18210 18252	Skinning deformations vary across vertices
T183	background_claim 18254 18385	In SSD and WPSD, this per-vertex computation is independent for each vertex and can be parallelized by a SIMD parallel architecture
T184	own_claim 18387 18544	We developed a parallel skinning algorithm for SSD and WPSD that is suitable to GPUs having a SIMD architecture with one-side communication to texture memory
T185	own_claim 18728 18979	The computation cost of the SSD skinning algorithm is O(n vertex × n joint ) from equations 1, 2, PSD is O(n vertex × n joint × n pose ) from equations 1, 2, 4, and WPSD is O(n vertex × n joint × n pose × n pose × n pose ) from equations 1, 2, 4, 5, 6
T186	own_claim 19059 19116	r i is same in all vertices and d i can be pre-calculated
T187	own_claim 18988 19051	computation cost of original PSD is defined by equation 1, 2, 4
R109	supports Arg1:T186 Arg2:T187	
T188	own_claim 19118 19242	The number of joints n joint and poses n pose can be reduced to the smaller numbers using the method developed by Kry et al.
T189	data 19245 19250	KJP02
R110	supports Arg1:T189 Arg2:T188	
T190	data 19277 19290	section 5.2.1
R111	supports Arg1:T190 Arg2:T188	
T191	background_claim 19358 19434	the Eigenskin method based on PSD was developed using GPU vertex programming
T192	data 19436 19441	KJP02
R112	supports Arg1:T192 Arg2:T191	
T193	background_claim 19444 19556	The vertex program uses a relatively small number of slow processing units compared with the fragment processors
T194	background_claim 19562 19637	the per-vertex computation cost of the original PSD is O(n joint × n pose )
T195	own_claim 19649 19653	WPSD
T196	own_claim 19736 19804	can clearly benefit from parallel computation on fragment processors
T197	own_claim 19655 19734	having higher pervertex computation cost O(n joint × n pose × n pose × n pose )
R113	supports Arg1:T197 Arg2:T195	
R114	parts_of_same Arg1:T196 Arg2:T195	
R115	supports Arg1:T194 Arg2:T195	
T198	own_claim 19993 20139	In order to minimize real-time computation, we separate possible pre-calculation steps and save the results into texture memory using texture maps
T199	own_claim 20149 20225	the value in the texture memory is not changed in the successive deformation
T200	own_claim 20227 20292	it can be pre-computed and stored in the read-only texture memory
R116	supports Arg1:T199 Arg2:T200	
T201	own_claim 20830 20886	The fragment processors cannot access vertex information
T202	own_claim 20897 20959	we can use texture memory to send data to the fragment program
T203	own_claim 21215 21267	These textures represent parameter v 0 in equation 2
T204	own_claim 21272 21343	each 3D element (x, y, z) is stored into the (r, g, b) value of a texel
T205	data 21346 21354	Figure 2
R117	supports Arg1:T205 Arg2:T204	
T206	background_claim 21797 21883	the distribution of skinning effects in an articulated body is local to several joints
T207	data 21886 21891	MMT97
T208	data 21892 21897	KJP02
R118	supports Arg1:T207 Arg2:T206	
R119	supports Arg1:T208 Arg2:T206	
T209	background_claim 21956 21989	deformations arising from the PIP
T210	background_claim 22017 22076	joint of index finger do not propagate to the other fingers
T211	background_claim 22082 22179	deformation on the middle phalanx of index finger is only affected by the movement of PIP and DIP
T212	background_claim 22196 22202	joints
R120	parts_of_same Arg1:T210 Arg2:T209	
R121	parts_of_same Arg1:T212 Arg2:T211	
R122	supports Arg1:T209 Arg2:T206	
R123	supports Arg1:T211 Arg2:T206	
T213	own_claim 22227 22394	we can reduce joint weight storage from the actual number of joint n joint to a smaller number of “principal joints” n  ̃ joint selected by sorting on the weight value
T214	own_claim 22520 22685	we can save the joint weights of entire geometry in two RGBA textures T w1 , T w2 each with size n vertex × 4(rgba) and store the entire information required for SSD
T215	own_claim 22699 22743	in four textures T v , T n , T w1 , and T w2
T216	own_claim 22396 22505	We threshold n  ̃ joint at four in our tests with an additional four elements to hold the related joint index
R124	supports Arg1:T216 Arg2:T214	
T217	data 22687 22697	equation 2
R125	supports Arg1:T217 Arg2:T214	
R126	parts_of_same Arg1:T215 Arg2:T214	
T218	own_claim 22746 22840	The displacement values calculated by equation 3 can be stored in n pose displacement textures
T219	own_claim 22939 23020	we need many sample poses to calculate accurate joint weights and PSD deformation
T220	data 22891 22915	complex joint structures
T221	data 22920 22937	a large DOF model
R127	supports Arg1:T221 Arg2:T219	
R128	supports Arg1:T220 Arg2:T219	
T222	own_claim 23037 23076	the joint weights can be pre-calculated
T223	own_claim 23078 23154	we can reduce the number of sample poses needed in real-time PSD computation
R129	supports Arg1:T222 Arg2:T223	
R130	contradicts Arg1:T223 Arg2:T219	
T224	background_claim 23191 23263	of pose space can yield an orthogonal basis called “ Eigendisplacement ”
T225	background_claim 23156 23159	PCA
R131	parts_of_same Arg1:T224 Arg2:T225	
T226	data 23265 23270	KJP02
R132	supports Arg1:T226 Arg2:T224	
T227	data 23276 23351	we reduce the size of pose space from n pose to n  ̃ pose “principal poses”
T228	own_claim 23379 23428	we can reduce the number of displacement textures
R133	supports Arg1:T227 Arg2:T228	
T229	own_claim 23444 23593	we set n  ̃ pose as eight in our experiment and save displacements of all poses into a RGB texture T d having size n vertex × 8( n  ̃ pose ) × 3(rgb)
T230	own_claim 23606 23841	from the two important observations of “principal joints” and “principal poses”, the original computation cost for SSD, PSD, and WPSD discussed in section 5.1 can be reduced using n  ̃ joint and n  ̃ pose rather than n joint and n pose
R134	supports Arg1:T228 Arg2:T230	
R135	supports Arg1:T229 Arg2:T230	
T231	background_claim 23871 23927	the weight r i in equation 4 is the same at every vertex
T232	background_claim 23844 23863	In the original PSD
T233	background_claim 23929 23978	we do not need to calculate this value in the GPU
R136	parts_of_same Arg1:T233 Arg2:T232	
R137	supports Arg1:T231 Arg2:T233	
T234	own_claim 23986 24026	the size of this value is just n  ̃ pose
T235	own_claim 24029 24110	we can simply pass them to the GPU as parameters without generating a texture map
R138	supports Arg1:T234 Arg2:T235	
T236	own_claim 24123 24202	we store all the information needed to calculate the original PSD at this point
R139	supports Arg1:T235 Arg2:T236	
T237	own_claim 24646 24697	they are not changed during the deformation process
T238	own_claim 24561 24638	The values in the texture maps are stored in the texture memory at setup time
R140	supports Arg1:T237 Arg2:T238	
T239	own_claim 24204 24415	In order to reduce real-time computation, we pre-calculate T j in equation 2 and λ in equation 5 and store them into another one channel texture T x having size n  ̃ pose × ( n  ̃ pose + n  ̃ joint × 3(x, y, z))
T240	own_claim 24430 24558	we store all the variables required to calculate WPSD, PSD, and SSD in six texture maps: T v , T n , T w1 , T w2 , T d , and T x
R141	supports Arg1:T239 Arg2:T240	
T241	background_claim 24699 24818	In current graphic card architectures, data transfer from CPU to GPU is slow compared with memory access within the GPU
T242	own_claim 24826 24974	the only data changed in each deformation and passed from CPU to GPU is a joint vector p a (size = n joint ) representing the current arbitrary pose
T243	own_claim 24976 25030	the memory access rate in our method is very efficient
R142	supports Arg1:T242 Arg2:T243	
T244	background_claim 25032 25115	In the original PSD method, an additional r k value (size = n  ̃ pose ) is required
T245	background_claim 26120 26181	vertex information cannot be accessed by the fragment program
T246	background_claim 26183 26251	vertex deformation on a GPU is usually performed by a vertex program
R143	supports Arg1:T245 Arg2:T246	
T247	data 26254 26259	KJP02
T248	data 26261 26265	BK05
R144	supports Arg1:T247 Arg2:T246	
R145	supports Arg1:T248 Arg2:T246	
T249	own_claim 26278 26330	we cannot access vertex data in the fragment program
T250	own_claim 26332 26402	the efficiency of parallel computation on a fragment program is higher
R146	semantically_same Arg1:T249 Arg2:T245	
T251	own_claim 26410 26526	the fragment processor has more processing units and each of them has more computation power than a vertex processor
R147	supports Arg1:T251 Arg2:T250	
R148	contradicts Arg1:T250 Arg2:T249	
T252	own_claim 26744 26859	We developed a parallel WPSD algorithms using the fragment processors to enhance the extent of parallel computation
T253	own_claim 27318 27376	the viewport is set to the same resolution as the textures
T254	own_claim 27378 27457	each fragment is exactly matched with each texel holding the vertex information
T255	own_claim 27463 27534	we can access each vertex using the texture coordinates of the fragment
T256	own_claim 27536 27635	vertex weights and displacements stored in the texture maps can also be accessed by similar methods
R149	supports Arg1:T253 Arg2:T254	
R150	supports Arg1:T254 Arg2:T255	
T257	background_claim 27637 27665	A similar idea was developed
T258	background_claim 27678 27745	to calculate ray tracing in a fragment program and is used in GPGPU
T259	background_claim 27784 27796	applications
R151	parts_of_same Arg1:T259 Arg2:T258	
R152	parts_of_same Arg1:T258 Arg2:T257	
T260	data 27670 27676	PBMH02
R153	supports Arg1:T260 Arg2:T257	
T261	data 27798 27801	GPG
T262	data 27803 27811	LHK ∗ 04
T263	data 27813 27817	PF05
R154	supports Arg1:T261 Arg2:T259	
R155	supports Arg1:T262 Arg2:T259	
R156	supports Arg1:T263 Arg2:T259	
T264	background_claim 27820 27827	The FBO
T265	background_claim 27850 27859	extension
T266	background_claim 27870 27913	supports rendering into an attached texture
R157	parts_of_same Arg1:T265 Arg2:T264	
R158	parts_of_same Arg1:T266 Arg2:T265	
T267	data 27862 27867	Gre05
R159	supports Arg1:T267 Arg2:T265	
T268	background_claim 27915 27941	This saves memory and time
T269	background_claim 27949 28011	there is no copy operation from frame buffer to texture buffer
R160	supports Arg1:T269 Arg2:T268	
R161	supports Arg1:T267 Arg2:T269	
T270	own_claim 28013 28187	We implemented our WPSD algorithm using the fragment program with the FBO extension to store the result directly into texture maps accessed by vertex program in the next pass
T271	data 28226 28237	Algorithm 1
R162	supports Arg1:T271 Arg2:T270	
T272	own_claim 30411 30434	multiple render targets
T273	own_claim 30442 30479	can combine the first and second pass
R163	parts_of_same Arg1:T273 Arg2:T272	
T274	own_claim 30485 30506	vertex buffer objects
T275	own_claim 30514 30583	could be used to render the deformed results back to the vertex array
R164	parts_of_same Arg1:T275 Arg2:T274	
T276	data 30585 30588	OPE
T277	data 30590 30593	GPG
T278	data 30595 30603	LHK ∗ 04
R165	supports Arg1:T276 Arg2:T275	
R166	supports Arg1:T277 Arg2:T275	
R167	supports Arg1:T278 Arg2:T275	
T279	own_claim 30656 30726	We tested our methods using upper arm models consisting of four joints
T280	own_claim 30765 30783	Each has three DOF
T281	own_claim 30788 30828	the wrist is the end joint having no DOF
T282	own_claim 30830 30924	Three different resolution meshes are used to test the performance of GPU parallel computation
T283	own_claim 30926 30991	the high-resolution model has 91460 triangles with 46036 vertices
T284	own_claim 30993 31056	the midresolution model has 22836 triangles with 11574 vertices
T285	own_claim 31062 31124	the low-resolution model has 5762 triangles with 2972 vertices
R168	supports Arg1:T283 Arg2:T282	
R169	supports Arg1:T284 Arg2:T282	
R170	supports Arg1:T285 Arg2:T282	
T286	data 31127 31135	Figure 4
R171	supports Arg1:T286 Arg2:T283	
R172	supports Arg1:T286 Arg2:T284	
R173	supports Arg1:T286 Arg2:T285	
T287	own_claim 31149 31225	these models are considerably more detailed than those used in current games
T288	own_claim 31230 31275	the reported frame rates would be much higher
T289	data 31279 31318	typical gameresolution models were used
R174	supports Arg1:T289 Arg2:T288	
R175	supports Arg1:T287 Arg2:T288	
T290	own_claim 31389 31444	models such as these will be in wide use in a few years
T291	own_claim 31344 31387	the expected growth of GPU processing power
T292	own_claim 31450 31552	algorithms such as WPSD will be required to produce realistic deformations at this level of resolution
R176	supports Arg1:T291 Arg2:T290	
R177	supports Arg1:T290 Arg2:T292	
R178	contradicts Arg1:T292 Arg2:T288	
T293	own_claim 31554 31687	Eight sample poses were created by Poser [Cur] and the joints weights and displacements of each sample were derived from these models
T294	data 31690 31698	Figure 5
R179	supports Arg1:T294 Arg2:T293	
T295	own_claim 31702 31763	Our parallel algorithm is based on three pass GPU computation
T296	own_claim 31765 31886	The fragment program for the 1st and 2nd pass, and the vertex program for the 3rd pass are implemented in the Cg language
T297	data 31889 31893	FK03
R180	supports Arg1:T297 Arg2:T296	
T298	own_claim 32120 32205	the maximum required memory space for the highest resolution model is just 6.8 Mbytes
T299	own_claim 31896 32015	For accuracy the GPU computation is performed by 32bit floating point operations with 32bit floating point texture maps
T300	own_claim 32207 32292	the size of the output texture T v ′ and T n ′ is the same as the size of T v and T n
T301	own_claim 32556 32660	On average, our GPU-based deformation shows around 20 times speed-up compared with CPU-based deformation
T302	data 32546 32553	table 1
R181	supports Arg1:T302 Arg2:T301	
T303	own_claim 32662 32719	GPU-based WPSD has roughly the same speed as CPUbased SSD
T304	own_claim 32732 32847	real-time applications using SSD can substitute WPSD running on the GPU without loosing their real-time performance
R182	supports Arg1:T303 Arg2:T304	
T305	own_claim 32855 32915	our algorithm shows speed-up for SSD and PSD as well as WPSD
T306	own_claim 32917 33026	applications can choose the most appropriate skinning method according to the required deformation and detail
R183	supports Arg1:T305 Arg2:T306	
T307	own_claim 36388 36473	we present a parallel skinning algorithm suitable for SIMD architectures such as GPUs
T308	own_claim 37012 37115	Articulated body skinning using SSD, PSD, and WPSD are efficiently parallelized by our GPU-based method
T309	own_claim 37121 37212	on a detailed model, we obtain around 20 times speed-up compared with CPU-based computation
T310	background_claim 37214 37342	Principal component compression of the examples and careful analysis of joint distributions can reduce the domain of computation
T311	data 37345 37350	KJP02
R184	supports Arg1:T311 Arg2:T310	
T312	own_claim 37356 37465	other algorithms based on the SSD, PSD, and shape interpolation may be parallelized on GPU using our approach
